{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nThis documentation describes how to use packages of the \nJuliaMusic\n. They are about reading, manipulating and saving data related with music. Most of the functionality comes in the form of the \nMIDI\n format which is described later on this page.\n\n\n\n\nNews\n\n\nCheck out the page \"News\" for the latest updates to our packages.\n\n\nLatest news: brand new \ntimeseries\n function!\n\n\n\n\nThe current documentation was built with the following package versions\n\n\n \n*\n \nMIDI\n \n......................\n \n1\n.\n4\n.\n2\n\n \n*\n \nMotifSequenceGenerator\n \n....\n \n0\n.\n2\n.\n0\n\n \n*\n \nMusicManipulations\n \n........\n \n0\n.\n7\n.\n0\n\n\n\n\n\n\nusing \nMaterial+MkDocs\n,  \nLiterate.jl\n and \nDocumenter.jl\n.\n\n\n\n\nCiting\n\n\nIf you used \nMIDI.jl\n or \nMusicManipulations.jl\n in research that resulted in publication, then please cite our paper using the following BibTeX entry:\n\n\n@article\n{\nDatseris2019,\n  doi = \n{\n10.21105/joss.01166\n}\n,\n  url = \n{\nhttps://doi.org/10.21105/joss.01166\n}\n,\n  year  = \n{\n2019\n}\n,\n  month = \n{\nmar\n}\n,\n  publisher = \n{\nThe Open Journal\n}\n,\n  volume = \n{\n4\n}\n,\n  number = \n{\n35\n}\n,\n  pages = \n{\n1166\n}\n,\n  author = \n{\nGeorge Datseris and Joel Hobson\n}\n,\n  title = \n{{\nMIDI\n}\n.jl: Simple and intuitive handling of MIDI data.\n}\n,\n  journal = \n{\nThe Journal of Open Source Software\n}\n\n\n}\n\n\n\n\n\n\n\n\nOverview\n\n\n\n\nMIDI\n\n\nMIDI.jl\n is a module that defines fundamental types like tracks, reading/writing functionality, note functionality and other basic stuff.\n\n\n\n\nBasic MIDI API\n : The API of basic types like midi files and tracks, as well as IO. Various utility functions are included as well.\n\n\nNotes\n : The \nNote\n construct describes a music note. Many convenience tools are also provided in the same page, like e.g. turning a note pitch to a string like \nA\u266f3\n.\n\n\n\n\n\n\nMusicManipulations\n\n\nThe \nMusicManipulations.jl\n package has more advanced functionality about note processing, data extraction, quantizing and other similar processes that related to music data.\n\n\n\n\nConvenience tools\n.\n\n\nQuantizing \n Classifying Notes\n on a given grid.\n\n\nAdvanced Music Data Extraction\n.\n\n\nPrinting notes into a Score\n\n\nMore coming soon.\n\n\n\n\n\n\nMotifSequenceGenerator\n\n\nMotifSequenceGenerator.jl\n is a very simple module that does a very simple thing: based on a pool of motifs with specified lengths, it makes a random sequence out of them so that the sequence also has a specified length!\n\n\n\n\nMotif Sequences\n introduces the module and has a basic usage example.\n\n\nMusic Motifs Example\n shows a real-world use case where the module is used to produce music sequences.\n\n\n\n\n\n\nMIDI: The least you need to know\n\n\nThis section serves as a crash-course on the MIDI format. For more info see the \nwikipedia\n page, read the \nofficial MIDI specifications\n or have a look at the comprehensive tutorial \nat recordingblogs.com\n.\n\n\nA MIDI file typically comes in pieces called tracks that play simultaneously. Each track can have 16 different channels, numbered 0-15. Each channel can be thought of as a single instrument, though that instrument can be changed throughout that track. A track contains events. The three types of events are MIDI events, META events, and system exclusive (SYSEX) events. All events begin with the time since the last event (dT) in ticks. The number of ticks per quarter note is given by the \ntpq\n of the midi file, \nMIDIFile.tpq\n (see \nMIDIFile\n).\n\n\n\n\nMIDI events handle things related to the actual notes as well as sound texture, such as playing a note or moving the pitch-wheel.\n\n\nMETA events take care of things like adding copyright text, authorship information, track naming etc.\n\n\nSYSEX events are used to transmit arbitrary data. Their contents depend on the intended recipient.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "This documentation describes how to use packages of the  JuliaMusic . They are about reading, manipulating and saving data related with music. Most of the functionality comes in the form of the  MIDI  format which is described later on this page.   News  Check out the page \"News\" for the latest updates to our packages.  Latest news: brand new  timeseries  function!   The current documentation was built with the following package versions    *   MIDI   ......................   1 . 4 . 2 \n  *   MotifSequenceGenerator   ....   0 . 2 . 0 \n  *   MusicManipulations   ........   0 . 7 . 0   using  Material+MkDocs ,   Literate.jl  and  Documenter.jl .", 
            "title": "Introduction"
        }, 
        {
            "location": "/#citing", 
            "text": "If you used  MIDI.jl  or  MusicManipulations.jl  in research that resulted in publication, then please cite our paper using the following BibTeX entry:  @article { Datseris2019,\n  doi =  { 10.21105/joss.01166 } ,\n  url =  { https://doi.org/10.21105/joss.01166 } ,\n  year  =  { 2019 } ,\n  month =  { mar } ,\n  publisher =  { The Open Journal } ,\n  volume =  { 4 } ,\n  number =  { 35 } ,\n  pages =  { 1166 } ,\n  author =  { George Datseris and Joel Hobson } ,\n  title =  {{ MIDI } .jl: Simple and intuitive handling of MIDI data. } ,\n  journal =  { The Journal of Open Source Software }  }", 
            "title": "Citing"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#midi", 
            "text": "MIDI.jl  is a module that defines fundamental types like tracks, reading/writing functionality, note functionality and other basic stuff.   Basic MIDI API  : The API of basic types like midi files and tracks, as well as IO. Various utility functions are included as well.  Notes  : The  Note  construct describes a music note. Many convenience tools are also provided in the same page, like e.g. turning a note pitch to a string like  A\u266f3 .", 
            "title": "MIDI"
        }, 
        {
            "location": "/#musicmanipulations", 
            "text": "The  MusicManipulations.jl  package has more advanced functionality about note processing, data extraction, quantizing and other similar processes that related to music data.   Convenience tools .  Quantizing   Classifying Notes  on a given grid.  Advanced Music Data Extraction .  Printing notes into a Score  More coming soon.", 
            "title": "MusicManipulations"
        }, 
        {
            "location": "/#motifsequencegenerator", 
            "text": "MotifSequenceGenerator.jl  is a very simple module that does a very simple thing: based on a pool of motifs with specified lengths, it makes a random sequence out of them so that the sequence also has a specified length!   Motif Sequences  introduces the module and has a basic usage example.  Music Motifs Example  shows a real-world use case where the module is used to produce music sequences.", 
            "title": "MotifSequenceGenerator"
        }, 
        {
            "location": "/#midi-the-least-you-need-to-know", 
            "text": "This section serves as a crash-course on the MIDI format. For more info see the  wikipedia  page, read the  official MIDI specifications  or have a look at the comprehensive tutorial  at recordingblogs.com .  A MIDI file typically comes in pieces called tracks that play simultaneously. Each track can have 16 different channels, numbered 0-15. Each channel can be thought of as a single instrument, though that instrument can be changed throughout that track. A track contains events. The three types of events are MIDI events, META events, and system exclusive (SYSEX) events. All events begin with the time since the last event (dT) in ticks. The number of ticks per quarter note is given by the  tpq  of the midi file,  MIDIFile.tpq  (see  MIDIFile ).   MIDI events handle things related to the actual notes as well as sound texture, such as playing a note or moving the pitch-wheel.  META events take care of things like adding copyright text, authorship information, track naming etc.  SYSEX events are used to transmit arbitrary data. Their contents depend on the intended recipient.", 
            "title": "MIDI: The least you need to know"
        }, 
        {
            "location": "/midi/io/", 
            "text": "Basic MIDI Structures\n\n\n\n\nMIDIFile\n\n\n#\n\n\nMIDI.MIDIFile\n \n \nType\n.\n\n\nMIDIFile\n \n:\n \nAny\n\n\n\n\n\n\nType representing a file of MIDI data.\n\n\nFields\n\n\n\n\nformat::UInt16\n : The format of the file. Can be 0, 1 or 2.\n\n\ntpq::Int16\n : The time division of the track, ticks-per-quarter-note.\n\n\ntracks::Array{MIDITrack, 1}\n : The array of contained tracks.\n\n\n\n\nTo read and write a MIDI file, use\n\n\n#\n\n\nMIDI.readMIDIFile\n \n \nFunction\n.\n\n\nreadMIDIFile\n(\nfilename\n::\nAbstractString\n)\n\n\n\n\n\n\nRead a file into a \nMIDIFile\n data type.\n\n\n#\n\n\nMIDI.writeMIDIFile\n \n \nFunction\n.\n\n\nwriteMIDIFile\n(\nfilename\n::\nAbstractString\n,\n \ndata\n::\nMIDIFile\n)\n\n\n\n\n\n\nWrite a \nMIDIFile\n as a \".mid\" file to the given filename.\n\n\nwriteMIDIFile\n(\nfilename\n::\nAbstractString\n,\n \nnotes\n::\nNotes\n)\n\n\n\n\n\n\nCreate a \nMIDIFile\n directly from \nnotes\n, using format 1.\n\n\n\n\n\n\nMIDITrack\n\n\nThe most important field of a \nMIDIFile\n is the \ntracks\n field. It contains as many tracks as the user wants. The tracks themselves contain all \"musical\" information in the form of the \"events\" we mentioned in the introduction:\n\n\n#\n\n\nMIDI.MIDITrack\n \n \nType\n.\n\n\nMIDITrack\n \n:\n \nAny\n\n\n\n\n\n\nMIDITrack\n is simply a container for \nTrackEvents\n, since its only field is \nevents::Vector{TrackEvent}\n.\n\n\nTrack chunks begin with four bytes spelling out \"MTrk\", followed by the length (in bytes) of the track (see \nreadvariablelength\n), followed by a sequence of events.\n\n\n#\n\n\nMIDI.TrackEvent\n \n \nType\n.\n\n\nTrackEvent\n \n:\n \nAny\n\n\n\n\n\n\nAbstract supertype for all MIDI events.\n\n\nAll track events begin with a variable length time value (see \nreadvariablelength\n) and have a field named \ndT\n which contains it. This number notes after how many ticks since the last event does the current even takes place.\n\n\nMIDIEvent\ns then resume with a MIDI channel message defined in \nconstants.jl\n. They're followed by 1 or 2 bytes, depending on the channel message (see \nMIDI.EVENTTYPETOLENGTH\n). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.\n\n\nMetaEvent\ns and \nSysexEvent\ns both resume with a specific byte (see \nconstants.jl\n).\n\n\n\n\nThe \nTrackEvent\n themselves can be one of three types:\n\n\nstruct\n \nMIDIEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \nstatus\n::\nUInt8\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\nstruct\n \nMetaEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \nmetatype\n::\nUInt8\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\nstruct\n \nSysexEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\n\n\n\nTypically the most relevant information of a \nMIDITrack\n are the notes contained within. For this reason, special functions \ngetnotes\n and \naddnotes!\n exist, which can be found in the \nNotes\n page.\n\n\n\n\nUtility functions\n\n\n#\n\n\nMIDI.BPM\n \n \nFunction\n.\n\n\nBPM\n(\nmidi\n)\n\n\n\n\n\n\nReturn the BPM where the given \nMIDIFile\n was exported at.\n\n\n#\n\n\nMIDI.ms_per_tick\n \n \nFunction\n.\n\n\nms_per_tick\n(\ntpq\n,\n \nbpm\n)\n\n\nms_per_tick\n(\nmidi\n::\nMIDIFile\n)\n\n\n\n\n\n\nReturn how many miliseconds is one tick, based on the beats per minute \nbpm\n and ticks per quarter note \ntpq\n.\n\n\n#\n\n\nMIDI.addevent!\n \n \nFunction\n.\n\n\naddevent!\n(\ntrack\n::\nMIDITrack\n,\n \ntime\n::\nInt\n,\n \nevent\n::\nTrackEvent\n)\n\n\n\n\n\n\nAdd an event to the \ntrack\n at given \ntime\n. The \ntime\n is in absolute time, not relative.\n\n\nIf you want to add multiple events in one go, you should use the \naddevents!\n function instead.\n\n\n#\n\n\nMIDI.addevents!\n \n \nFunction\n.\n\n\naddevents!\n(\ntrack\n::\nMIDITrack\n,\n \ntimes\n,\n \nevents\n)\n\n\n\n\n\n\nAdd given \nevents\n to given \ntrack\n at given \ntimes\n, internally doing all translations from absolute time to relative time.\n\n\nUsing this function is more efficient than a loop over single \naddevent!\n calls.\n\n\n#\n\n\nMIDI.trackname\n \n \nFunction\n.\n\n\ntrackname\n(\ntrack\n::\nMIDI\n.\nMIDITrack\n)\n\n\n\n\n\n\nReturn the name of the given \ntrack\n as a string, by finding the \"track name\" \nMetaEvent\n.\n\n\n#\n\n\nMIDI.addtrackname!\n \n \nFunction\n.\n\n\naddtrackname!\n(\ntrack\n::\nMIDI\n.\nMIDITrack\n,\n \nname\n::\nString\n)\n\n\n\n\n\n\nAdd a name to the given \ntrack\n by attaching the \"track name\" \nMetaEvent\n to the start of the \ntrack\n.\n\n\n#\n\n\nMIDI.textevent\n \n \nFunction\n.\n\n\ntextevent\n(\neventtype\n,\n \ntext\n)\n\n\n\n\n\n\nCreate an event using the string \ntext\n. The \neventtype\n can be \n:text, :lyric, :marker\n, which will create the appropriate type of \nMetaEvent\n.\n\n\nThe returned event can be added to a \nMIDITrack\n via either \naddevent!\n or \naddevents!\n for multiple events.\n\n\nNotice\n - Cubase can read the marker events and MuseScore can read the lyrics events. We haven't seen any editor that can read the text events, so far.\n\n\n#\n\n\nMIDI.findtextevents\n \n \nFunction\n.\n\n\nfindtextevents\n(\neventtype\n,\n \ntrack\n)\n\n\n\n\n\n\nFind all \"text\" events specifield by \neventtype\n in the \ntrack\n. The \neventtype\n can be \n:text, :lyric, :marker\n, which will find the appropriate \nMetaEvent\ns.\n\n\nFor convenience, this function does not return the events themselves. Instead, it returns three vectors: the first is the strings of the events, the second is the indices of the events in the \ntrack\n and the third is the absolute position of the events (since start of \ntrack\n).\n\n\nNotice\n - common music score editors like e.g. MuseScore, GuitarPro, etc., do not export the lyrics and text information when exporting midi files.\n\n\n\n\nLow-Level API\n\n\nIn this section we show the low-level API that allows one to actually read bytes from a file and transform them into Julia structures.\n\n\n#\n\n\nMIDI.readvariablelength\n \n \nFunction\n.\n\n\nreadvariablelength\n(\nf\n::\nIO\n)\n\n\n\n\n\n\nVariable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we're looking at the last byte in the sequence. The remaining 7 bits indicate the number.\n\n\nOther useful functions that are not exported are\n\n\nwriteevent\n\n\nreadMIDIevent\n\n\nreadmetaevent\n\n\nreadsysexevent\n\n\nget_abs_pos\n\n\n\n\n\n\n\n\nLastly, see the file \nMIDI/src/constants.jl\n for message types, event types, etc.", 
            "title": "MIDI files"
        }, 
        {
            "location": "/midi/io/#basic-midi-structures", 
            "text": "", 
            "title": "Basic MIDI Structures"
        }, 
        {
            "location": "/midi/io/#midifile", 
            "text": "#  MIDI.MIDIFile     Type .  MIDIFile   :   Any   Type representing a file of MIDI data.  Fields   format::UInt16  : The format of the file. Can be 0, 1 or 2.  tpq::Int16  : The time division of the track, ticks-per-quarter-note.  tracks::Array{MIDITrack, 1}  : The array of contained tracks.   To read and write a MIDI file, use  #  MIDI.readMIDIFile     Function .  readMIDIFile ( filename :: AbstractString )   Read a file into a  MIDIFile  data type.  #  MIDI.writeMIDIFile     Function .  writeMIDIFile ( filename :: AbstractString ,   data :: MIDIFile )   Write a  MIDIFile  as a \".mid\" file to the given filename.  writeMIDIFile ( filename :: AbstractString ,   notes :: Notes )   Create a  MIDIFile  directly from  notes , using format 1.", 
            "title": "MIDIFile"
        }, 
        {
            "location": "/midi/io/#miditrack", 
            "text": "The most important field of a  MIDIFile  is the  tracks  field. It contains as many tracks as the user wants. The tracks themselves contain all \"musical\" information in the form of the \"events\" we mentioned in the introduction:  #  MIDI.MIDITrack     Type .  MIDITrack   :   Any   MIDITrack  is simply a container for  TrackEvents , since its only field is  events::Vector{TrackEvent} .  Track chunks begin with four bytes spelling out \"MTrk\", followed by the length (in bytes) of the track (see  readvariablelength ), followed by a sequence of events.  #  MIDI.TrackEvent     Type .  TrackEvent   :   Any   Abstract supertype for all MIDI events.  All track events begin with a variable length time value (see  readvariablelength ) and have a field named  dT  which contains it. This number notes after how many ticks since the last event does the current even takes place.  MIDIEvent s then resume with a MIDI channel message defined in  constants.jl . They're followed by 1 or 2 bytes, depending on the channel message (see  MIDI.EVENTTYPETOLENGTH ). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.  MetaEvent s and  SysexEvent s both resume with a specific byte (see  constants.jl ).   The  TrackEvent  themselves can be one of three types:  struct   MIDIEvent   :   TrackEvent \n     dT :: Int \n     status :: UInt8 \n     data :: Array { UInt8 , 1 }  end  struct   MetaEvent   :   TrackEvent \n     dT :: Int \n     metatype :: UInt8 \n     data :: Array { UInt8 , 1 }  end  struct   SysexEvent   :   TrackEvent \n     dT :: Int \n     data :: Array { UInt8 , 1 }  end   Typically the most relevant information of a  MIDITrack  are the notes contained within. For this reason, special functions  getnotes  and  addnotes!  exist, which can be found in the  Notes  page.", 
            "title": "MIDITrack"
        }, 
        {
            "location": "/midi/io/#utility-functions", 
            "text": "#  MIDI.BPM     Function .  BPM ( midi )   Return the BPM where the given  MIDIFile  was exported at.  #  MIDI.ms_per_tick     Function .  ms_per_tick ( tpq ,   bpm )  ms_per_tick ( midi :: MIDIFile )   Return how many miliseconds is one tick, based on the beats per minute  bpm  and ticks per quarter note  tpq .  #  MIDI.addevent!     Function .  addevent! ( track :: MIDITrack ,   time :: Int ,   event :: TrackEvent )   Add an event to the  track  at given  time . The  time  is in absolute time, not relative.  If you want to add multiple events in one go, you should use the  addevents!  function instead.  #  MIDI.addevents!     Function .  addevents! ( track :: MIDITrack ,   times ,   events )   Add given  events  to given  track  at given  times , internally doing all translations from absolute time to relative time.  Using this function is more efficient than a loop over single  addevent!  calls.  #  MIDI.trackname     Function .  trackname ( track :: MIDI . MIDITrack )   Return the name of the given  track  as a string, by finding the \"track name\"  MetaEvent .  #  MIDI.addtrackname!     Function .  addtrackname! ( track :: MIDI . MIDITrack ,   name :: String )   Add a name to the given  track  by attaching the \"track name\"  MetaEvent  to the start of the  track .  #  MIDI.textevent     Function .  textevent ( eventtype ,   text )   Create an event using the string  text . The  eventtype  can be  :text, :lyric, :marker , which will create the appropriate type of  MetaEvent .  The returned event can be added to a  MIDITrack  via either  addevent!  or  addevents!  for multiple events.  Notice  - Cubase can read the marker events and MuseScore can read the lyrics events. We haven't seen any editor that can read the text events, so far.  #  MIDI.findtextevents     Function .  findtextevents ( eventtype ,   track )   Find all \"text\" events specifield by  eventtype  in the  track . The  eventtype  can be  :text, :lyric, :marker , which will find the appropriate  MetaEvent s.  For convenience, this function does not return the events themselves. Instead, it returns three vectors: the first is the strings of the events, the second is the indices of the events in the  track  and the third is the absolute position of the events (since start of  track ).  Notice  - common music score editors like e.g. MuseScore, GuitarPro, etc., do not export the lyrics and text information when exporting midi files.", 
            "title": "Utility functions"
        }, 
        {
            "location": "/midi/io/#low-level-api", 
            "text": "In this section we show the low-level API that allows one to actually read bytes from a file and transform them into Julia structures.  #  MIDI.readvariablelength     Function .  readvariablelength ( f :: IO )   Variable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we're looking at the last byte in the sequence. The remaining 7 bits indicate the number.  Other useful functions that are not exported are  writeevent  readMIDIevent  readmetaevent  readsysexevent  get_abs_pos    Lastly, see the file  MIDI/src/constants.jl  for message types, event types, etc.", 
            "title": "Low-Level API"
        }, 
        {
            "location": "/midi/notes/", 
            "text": "Notes\n\n\nNote information in MIDI files is typically encoded using \nNOTEON\n and \nNOTEOFF\n events. A music note however contains more information besides the start and end; we bundle this information with the following two types:\n\n\n#\n\n\nMIDI.Note\n \n \nType\n.\n\n\nNote\n \n:\n \nAbstractNote\n\n\n\n\n\n\nData structure describing a \"music note\".\n\n\nFields:\n\n\n\n\npitch::UInt8\n : Pitch, starting from C0 = 0, adding one per semitone (middle-C is 60).\n\n\nvelocity::UInt8\n : Dynamic intensity. Cannot be higher than 127 (0x7F).\n\n\nposition::UInt\n : Position in absolute time (since beginning of track), in ticks.\n\n\nduration::UInt\n : Duration in ticks.\n\n\nchannel::UInt8 = 0\n : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).\n\n\n\n\nIf the \nchannel\n of the note is \n0\n (default) it is not printed with \nshow\n.\n\n\n#\n\n\nMIDI.Notes\n \n \nType\n.\n\n\nNotes\n{\nN\n:\nAbstractNote\n}\n\n\n\n\n\n\nData structure describing a collection of \"music notes\", bundled with a ticks per quarter note measure.\n\n\nFields:\n\n\n\n\nnotes::Vector{N}\n\n\ntpq::Int16\n : Ticks per quarter note. Defines the fundamental unit of measurement  of a note's position and duration, as well as the length of one quarter note.  Takes values from 1 to 960.\n\n\n\n\nNotes\n is iterated and accessed as if iterating or accessing its field \nnotes\n.\n\n\n\n\nTo get all the notes in a \nMIDITrack\n, you can use\n\n\n#\n\n\nMIDI.getnotes\n \n \nFunction\n.\n\n\ngetnotes\n(\nmidi\n::\nMIDIFile\n,\n \ntrackno\n \n=\n \n2\n)\n\n\n\n\n\n\nFind all NOTEON and NOTEOFF midi events in the \ntrackno\n track of a \nmidi\n, that correspond to the same note value (pitch) and convert them into the \nNote\n datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity. \ngetnotes\n takes care of this.\n\n\nNotice that the first track of a \nmidi\n typically doesn't have any notes, which is why the function defaults to track 2.\n\n\ngetnotes\n(\ntrack\n::\nMIDITrack\n,\n \ntpq\n \n=\n \n960\n)\n\n\n\n\n\n\nFind the notes from \ntrack\n directly, passing also the ticks per quarter note.\n\n\nReturns: \nNotes{Note}\n, setting the ticks per quarter note as \ntpq\n. You can find the originally exported ticks per quarter note from the original \nMIDIFile\n through \nmidi.tpq\n.\n\n\n\n\nIf you have some notes and you want to add them to a track, use\n\n\n#\n\n\nMIDI.addnotes!\n \n \nFunction\n.\n\n\naddnotes!\n(\ntrack\n::\nMIDITrack\n,\n \nnotes\n)\n\n\n\n\n\n\nAdd given \nnotes\n to given \ntrack\n, internally doing all translations from absolute time to relative time.\n\n\n\n\nFinally, you can use the function \ngetnotnotes(track)\n to get all \nTrackEvents\n that are \nnot\n \nNOTEON\n or \nNOTEOFF\n.\n\n\n\n\nWrite Example\n\n\nusing\n \nMIDI\n\n\nC\n \n=\n \nNote\n(\n60\n,\n \n96\n,\n \n0\n,\n \n192\n)\n\n\nE\n \n=\n \nNote\n(\n64\n,\n \n96\n,\n \n48\n,\n \n144\n)\n\n\nG\n \n=\n \nNote\n(\n67\n,\n \n96\n,\n \n96\n,\n \n96\n)\n\n\n\ninc\n \n=\n \n192\n\n\nfile\n \n=\n \nMIDIFile\n()\n\n\ntrack\n \n=\n \nMIDITrack\n()\n\n\nnotes\n \n=\n \nNotes\n()\n \n# tpq automatically = 960\n\n\n\npush!\n(\nnotes\n,\n \nC\n)\n\n\npush!\n(\nnotes\n,\n \nE\n)\n\n\npush!\n(\nnotes\n,\n \nG\n)\n\n\n\n# Notes one octave higher\n\n\nC\n \n=\n \nNote\n(\n60\n \n+\n \n12\n,\n \n96\n,\n \nC\n.\nposition\n+\ninc\n,\n \n192\n)\n\n\nE\n \n=\n \nNote\n(\n64\n \n+\n \n12\n,\n \n96\n,\n \nE\n.\nposition\n+\ninc\n,\n \n144\n)\n\n\nG\n \n=\n \nNote\n(\n67\n \n+\n \n12\n,\n \n96\n,\n \nG\n.\nposition\n+\ninc\n,\n \n96\n)\n\n\n\naddnotes!\n(\ntrack\n,\n \nnotes\n)\n\n\naddtrackname!\n(\ntrack\n,\n \nsimple track\n)\n\n\npush!\n(\nfile\n.\ntracks\n,\n \ntrack\n)\n\n\nwriteMIDIFile\n(\ntest.mid\n,\n \nfile\n)\n\n\n\n\n\n\n\n\nRead Example\n\n\nusing\n \nMIDI\n\n\nmidi\n \n=\n \nreadMIDIFile\n(\ntestmidi\n())\n\n\n\n\n\n\nMIDIFile\n:\n\n  \nformat\n:\n \n1\n\n  \ntracks\n:\n \n4\n\n  \ntpq\n:\n \n960\n\n\n\n\n\n\n# Track number 3 is a quantized bass MIDI track\n\n\nbass\n \n=\n \nmidi\n.\ntracks\n[\n3\n]\n\n\nnotes\n \n=\n \ngetnotes\n(\nbass\n,\n \nmidi\n.\ntpq\n)\n\n\nprintln\n(\nNotes of track \n$\n(\ntrackname\n(\nbass\n))\n:\n)\n\n\nnotes\n\n\n\n\n\n\n177\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nA\n\u266f\n2\n \n|\n \nvel\n \n=\n \n95\n  \n|\n \npos\n \n=\n \n7680\n,\n \ndur\n \n=\n \n690\n\n \nNote\n \nA\n\u266f\n2\n \n|\n \nvel\n \n=\n \n71\n  \n|\n \npos\n \n=\n \n9280\n,\n \ndur\n \n=\n \n308\n\n \nNote\n \nG\n\u266f\n2\n \n|\n \nvel\n \n=\n \n52\n  \n|\n \npos\n \n=\n \n9600\n,\n \ndur\n \n=\n \n668\n\n \nNote\n \nG\n\u266f\n2\n \n|\n \nvel\n \n=\n \n58\n  \n|\n \npos\n \n=\n \n11200\n,\n \ndur\n \n=\n \n338\n\n \nNote\n \nG2\n  \n|\n \nvel\n \n=\n \n71\n  \n|\n \npos\n \n=\n \n11520\n,\n \ndur\n \n=\n \n701\n\n \nNote\n \nG\n\u266f\n2\n \n|\n \nvel\n \n=\n \n83\n  \n|\n \npos\n \n=\n \n13120\n,\n \ndur\n \n=\n \n281\n\n \nNote\n \nG2\n  \n|\n \nvel\n \n=\n \n73\n  \n|\n \npos\n \n=\n \n13440\n,\n \ndur\n \n=\n \n855\n\n  \n\u22ee\n\n \nNote\n \nF\n\u266f\n1\n \n|\n \nvel\n \n=\n \n73\n  \n|\n \npos\n \n=\n \n185280\n,\n \ndur\n \n=\n \n878\n\n \nNote\n \nF1\n  \n|\n \nvel\n \n=\n \n85\n  \n|\n \npos\n \n=\n \n186240\n,\n \ndur\n \n=\n \n964\n\n \nNote\n \nA1\n  \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n187200\n,\n \ndur\n \n=\n \n904\n\n \nNote\n \nA\n\u266f\n1\n \n|\n \nvel\n \n=\n \n81\n  \n|\n \npos\n \n=\n \n188160\n,\n \ndur\n \n=\n \n900\n\n \nNote\n \nB1\n  \n|\n \nvel\n \n=\n \n77\n  \n|\n \npos\n \n=\n \n189120\n,\n \ndur\n \n=\n \n945\n\n \nNote\n \nC2\n  \n|\n \nvel\n \n=\n \n83\n  \n|\n \npos\n \n=\n \n190080\n,\n \ndur\n \n=\n \n847\n\n \nNote\n \nF2\n  \n|\n \nvel\n \n=\n \n90\n  \n|\n \npos\n \n=\n \n191040\n,\n \ndur\n \n=\n \n713\n\n\n\n\n\n\n\n\nPitch to \nInt\n convertion\n\n\n#\n\n\nMIDI.name_to_pitch\n \n \nFunction\n.\n\n\nname_to_pitch\n(\np\n::\nString\n)\n \n-\n \nInt\n\n\n\n\n\n\nReturn the pitch value of the given note name \np\n, which can be of the form \ncapital_letter*sharp*octave\n where:\n\n\n\n\ncapital_letter\n : from \n\"A\"\n to \n\"G\"\n.\n\n\nsharp\n : one of \n\"#\"\n \n\"\u266f\"\n or \n\"\"\n.\n\n\noctave\n : any integer (as a string), the octave number (an octave is 12 pitches). If not given it is assumed \n\"5\"\n.\n\n\n\n\nWe define E.g. \nname_to_pitch(\"C4\") === 60\n (i.e. string \n\"C4\"\n, representing the middle-C, corresponds to be pitch \n60\n).\n\n\nSee http://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/C\n(musical\nnote) .\n\n\n#\n\n\nMIDI.pitch_to_name\n \n \nFunction\n.\n\n\npitch_to_name\n(\npitch\n)\n \n-\n \nstring\n\n\n\n\n\n\nReturn the name of the pitch, e.g. \nF5\n, \nA\u266f3\n etc. in modern notation given the value in integer.\n\n\nReminder: middle C has pitch \n60\n and is displayed as \nC4\n.\n\n\n#\n\n\nMusicManipulations.note_to_fundamental\n \n \nFunction\n.\n\n\nnote_to_fundamental\n(\nnote\n(\ns\n))\n\n\n\n\n\n\nReturn a \nString\n or \nVector{String}\n with the fundamental pitch of the notes (i.e. without the octave information).\n\n\n\n\nConvenience Tools\n\n\nThe functions \nvelocities, positions, pitches, durations\n return the respective property when given some \nNotes\n.\n\n\nOther convenience functions follow:\n\n\n#\n\n\nMusicManipulations.translate\n \n \nFunction\n.\n\n\ntranslate\n(\nnotes\n,\n \nticks\n)\n\n\n\n\n\n\nTranslate the \nnotes\n for the given amount of \nticks\n.\n\n\n#\n\n\nBase.transpose\n \n \nFunction\n.\n\n\ntranspose\n(\nnotes\n,\n \nsemitones\n)\n\n\n\n\n\n\nTranspose the \nnotes\n for the given amount of \nsemitones\n.\n\n\n#\n\n\nMusicManipulations.randomnotes\n \n \nFunction\n.\n\n\nrandomnotes\n(\nn\n::\nInt\n,\n \ntpq\n \n=\n \n960\n)\n\n\n\n\n\n\nGenerate some random notes that start sequentially.\n\n\n#\n\n\nMusicManipulations.subdivision\n \n \nFunction\n.\n\n\nsubdivision\n(\nn\n::\nInt\n,\n \ntpq\n)\n\n\n\n\n\n\nReturn how many ticks is the duration of the subdivision of a 4/4-bar into \nn\n equal parts, assuming the ticks per quarter note are \ntpq\n.\n\n\nFor example, for sixteenth notes you would do \nsubdivision(16, tpq)\n, for eigth-note triplets \nsubdivision(12, tpq)\n and so on.", 
            "title": "Notes"
        }, 
        {
            "location": "/midi/notes/#notes", 
            "text": "Note information in MIDI files is typically encoded using  NOTEON  and  NOTEOFF  events. A music note however contains more information besides the start and end; we bundle this information with the following two types:  #  MIDI.Note     Type .  Note   :   AbstractNote   Data structure describing a \"music note\".  Fields:   pitch::UInt8  : Pitch, starting from C0 = 0, adding one per semitone (middle-C is 60).  velocity::UInt8  : Dynamic intensity. Cannot be higher than 127 (0x7F).  position::UInt  : Position in absolute time (since beginning of track), in ticks.  duration::UInt  : Duration in ticks.  channel::UInt8 = 0  : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).   If the  channel  of the note is  0  (default) it is not printed with  show .  #  MIDI.Notes     Type .  Notes { N : AbstractNote }   Data structure describing a collection of \"music notes\", bundled with a ticks per quarter note measure.  Fields:   notes::Vector{N}  tpq::Int16  : Ticks per quarter note. Defines the fundamental unit of measurement  of a note's position and duration, as well as the length of one quarter note.  Takes values from 1 to 960.   Notes  is iterated and accessed as if iterating or accessing its field  notes .   To get all the notes in a  MIDITrack , you can use  #  MIDI.getnotes     Function .  getnotes ( midi :: MIDIFile ,   trackno   =   2 )   Find all NOTEON and NOTEOFF midi events in the  trackno  track of a  midi , that correspond to the same note value (pitch) and convert them into the  Note  datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity.  getnotes  takes care of this.  Notice that the first track of a  midi  typically doesn't have any notes, which is why the function defaults to track 2.  getnotes ( track :: MIDITrack ,   tpq   =   960 )   Find the notes from  track  directly, passing also the ticks per quarter note.  Returns:  Notes{Note} , setting the ticks per quarter note as  tpq . You can find the originally exported ticks per quarter note from the original  MIDIFile  through  midi.tpq .   If you have some notes and you want to add them to a track, use  #  MIDI.addnotes!     Function .  addnotes! ( track :: MIDITrack ,   notes )   Add given  notes  to given  track , internally doing all translations from absolute time to relative time.   Finally, you can use the function  getnotnotes(track)  to get all  TrackEvents  that are  not   NOTEON  or  NOTEOFF .", 
            "title": "Notes"
        }, 
        {
            "location": "/midi/notes/#write-example", 
            "text": "using   MIDI  C   =   Note ( 60 ,   96 ,   0 ,   192 )  E   =   Note ( 64 ,   96 ,   48 ,   144 )  G   =   Note ( 67 ,   96 ,   96 ,   96 )  inc   =   192  file   =   MIDIFile ()  track   =   MIDITrack ()  notes   =   Notes ()   # tpq automatically = 960  push! ( notes ,   C )  push! ( notes ,   E )  push! ( notes ,   G )  # Notes one octave higher  C   =   Note ( 60   +   12 ,   96 ,   C . position + inc ,   192 )  E   =   Note ( 64   +   12 ,   96 ,   E . position + inc ,   144 )  G   =   Note ( 67   +   12 ,   96 ,   G . position + inc ,   96 )  addnotes! ( track ,   notes )  addtrackname! ( track ,   simple track )  push! ( file . tracks ,   track )  writeMIDIFile ( test.mid ,   file )", 
            "title": "Write Example"
        }, 
        {
            "location": "/midi/notes/#read-example", 
            "text": "using   MIDI  midi   =   readMIDIFile ( testmidi ())   MIDIFile : \n   format :   1 \n   tracks :   4 \n   tpq :   960   # Track number 3 is a quantized bass MIDI track  bass   =   midi . tracks [ 3 ]  notes   =   getnotes ( bass ,   midi . tpq )  println ( Notes of track  $ ( trackname ( bass )) : )  notes   177   Notes   with   tpq = 960 \n  Note   A \u266f 2   |   vel   =   95    |   pos   =   7680 ,   dur   =   690 \n  Note   A \u266f 2   |   vel   =   71    |   pos   =   9280 ,   dur   =   308 \n  Note   G \u266f 2   |   vel   =   52    |   pos   =   9600 ,   dur   =   668 \n  Note   G \u266f 2   |   vel   =   58    |   pos   =   11200 ,   dur   =   338 \n  Note   G2    |   vel   =   71    |   pos   =   11520 ,   dur   =   701 \n  Note   G \u266f 2   |   vel   =   83    |   pos   =   13120 ,   dur   =   281 \n  Note   G2    |   vel   =   73    |   pos   =   13440 ,   dur   =   855 \n   \u22ee \n  Note   F \u266f 1   |   vel   =   73    |   pos   =   185280 ,   dur   =   878 \n  Note   F1    |   vel   =   85    |   pos   =   186240 ,   dur   =   964 \n  Note   A1    |   vel   =   88    |   pos   =   187200 ,   dur   =   904 \n  Note   A \u266f 1   |   vel   =   81    |   pos   =   188160 ,   dur   =   900 \n  Note   B1    |   vel   =   77    |   pos   =   189120 ,   dur   =   945 \n  Note   C2    |   vel   =   83    |   pos   =   190080 ,   dur   =   847 \n  Note   F2    |   vel   =   90    |   pos   =   191040 ,   dur   =   713", 
            "title": "Read Example"
        }, 
        {
            "location": "/midi/notes/#pitch-to-int-convertion", 
            "text": "#  MIDI.name_to_pitch     Function .  name_to_pitch ( p :: String )   -   Int   Return the pitch value of the given note name  p , which can be of the form  capital_letter*sharp*octave  where:   capital_letter  : from  \"A\"  to  \"G\" .  sharp  : one of  \"#\"   \"\u266f\"  or  \"\" .  octave  : any integer (as a string), the octave number (an octave is 12 pitches). If not given it is assumed  \"5\" .   We define E.g.  name_to_pitch(\"C4\") === 60  (i.e. string  \"C4\" , representing the middle-C, corresponds to be pitch  60 ).  See http://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/C (musical note) .  #  MIDI.pitch_to_name     Function .  pitch_to_name ( pitch )   -   string   Return the name of the pitch, e.g.  F5 ,  A\u266f3  etc. in modern notation given the value in integer.  Reminder: middle C has pitch  60  and is displayed as  C4 .  #  MusicManipulations.note_to_fundamental     Function .  note_to_fundamental ( note ( s ))   Return a  String  or  Vector{String}  with the fundamental pitch of the notes (i.e. without the octave information).", 
            "title": "Pitch to Int convertion"
        }, 
        {
            "location": "/midi/notes/#convenience-tools", 
            "text": "The functions  velocities, positions, pitches, durations  return the respective property when given some  Notes .  Other convenience functions follow:  #  MusicManipulations.translate     Function .  translate ( notes ,   ticks )   Translate the  notes  for the given amount of  ticks .  #  Base.transpose     Function .  transpose ( notes ,   semitones )   Transpose the  notes  for the given amount of  semitones .  #  MusicManipulations.randomnotes     Function .  randomnotes ( n :: Int ,   tpq   =   960 )   Generate some random notes that start sequentially.  #  MusicManipulations.subdivision     Function .  subdivision ( n :: Int ,   tpq )   Return how many ticks is the duration of the subdivision of a 4/4-bar into  n  equal parts, assuming the ticks per quarter note are  tpq .  For example, for sixteenth notes you would do  subdivision(16, tpq) , for eigth-note triplets  subdivision(12, tpq)  and so on.", 
            "title": "Convenience Tools"
        }, 
        {
            "location": "/mm/quantizing/", 
            "text": "Quantizing\n\n\n\n\nQuantization\n\n\nQuantization\n is the process of moving all note starting positions to a specified and periodic grid. This \"grid\" does not have the be equi-spaced but it has to be periodic per quarter note.\n\n\n#\n\n\nMusicManipulations.quantize\n \n \nFunction\n.\n\n\nquantize\n(\nnotes\n::\nNotes\n,\n \ngrid\n,\n \nduration\n \n=\n \ntrue\n)\n\n\nquantize\n(\nnote\n::\nAbstractNote\n,\n \ngrid\n,\n \ntpq\n::\nInteger\n)\n\n\n\n\n\n\nReturn a quantized copy of the given notes on the given \ngrid\n, which can be any sorted iterable that starts on \n0\n and ends on \n1\n.\n\n\nEach note is quantized (relocated) to its closest point of the \ngrid\n, by first identifying that point using \nclassify\n. It is assumed that the grid is the same for all quarter notes of the track.\n\n\nIf \nduration\n is \ntrue\n, the function also quantizes the duration of the notes on the same grid, while ensuring a duration spanning at least one grid point.\n\n\nThis function respects the notes' absolute position and quantizes in absolute position, not relative.\n\n\n\n\nHere are some examples\n\n\nusing\n \nMusicManipulations\n\n\nmidi\n \n=\n \nreadMIDIFile\n(\ntestmidi\n())\n\n\nnotes\n \n=\n \ngetnotes\n(\nmidi\n,\n \n4\n)\n\n\n\nsixteens\n \n=\n \n0\n:\n1\n//\n4\n:\n1\n\n\n\nnotes16\n \n=\n \nquantize\n(\nnotes\n,\n \nsixteens\n)\n\n\n\nswung_8s\n \n=\n \n[\n0\n,\n \n2\n//\n3\n,\n \n1\n]\n\n\n\nswung_notes\n \n=\n \nquantize\n(\nnotes\n,\n \nswung_8s\n)\n\n\n\n\n\n\n533\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nF4\n  \n|\n \nvel\n \n=\n \n69\n  \n|\n \npos\n \n=\n \n7360\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nA\n\u266f\n4\n \n|\n \nvel\n \n=\n \n85\n  \n|\n \npos\n \n=\n \n7680\n,\n \ndur\n \n=\n \n640\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n91\n  \n|\n \npos\n \n=\n \n8320\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nD4\n  \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n8320\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nG\n\u266f\n3\n \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n8320\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nA\n\u266f\n4\n \n|\n \nvel\n \n=\n \n76\n  \n|\n \npos\n \n=\n \n8640\n,\n \ndur\n \n=\n \n640\n\n \nNote\n \nG4\n  \n|\n \nvel\n \n=\n \n66\n  \n|\n \npos\n \n=\n \n9280\n,\n \ndur\n \n=\n \n320\n\n  \n\u22ee\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n91\n  \n|\n \npos\n \n=\n \n189760\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nA4\n  \n|\n \nvel\n \n=\n \n99\n  \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nD\n\u266f\n4\n \n|\n \nvel\n \n=\n \n101\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n960\n\n \nNote\n \nA3\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n960\n\n \nNote\n \nD4\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n960\n\n \nNote\n \nG4\n  \n|\n \nvel\n \n=\n \n109\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n320\n\n\n\n\n\n\nThe first quantization quantized the notes on the 16-th subdivision. The second one did something a bit more specialized, as it separated the notes to \"quarter notes\" and swung 8th notes, the typical way a Jazz standard (like Serenade To A Cuckoo) is played.\n\n\n\n\nClassification\n\n\nquantize\n works in two steps. In the first step, each note is \"classified\", according to which is the closest grid point to this note (modulo the quarter note).\n\n\n#\n\n\nMusicManipulations.classify\n \n \nFunction\n.\n\n\nclassify\n(\nnotes\n::\nNotes\n,\n \ngrid\n)\n\n\nclassify\n(\nnote\n::\nAbstractNote\n,\n \ngrid\n,\n \ntpq\n::\nInteger\n)\n\n\n\n\n\n\nClassify given notes according to the given grid.\n\n\nReturns an integer (or vector of integers) that corresponds to the index of the closest grid point to the note position modulo the quarter note. \n1\n means start of the grid and \nlength(grid)\n means end of the grid (i.e. \nnext\n quarter note).\n\n\nAfter the notes have been classified, this classification vector is used to simply relocate all notes to the closest grid point (modulo the quarter note).", 
            "title": "Quantizing"
        }, 
        {
            "location": "/mm/quantizing/#quantizing", 
            "text": "", 
            "title": "Quantizing"
        }, 
        {
            "location": "/mm/quantizing/#quantization", 
            "text": "Quantization  is the process of moving all note starting positions to a specified and periodic grid. This \"grid\" does not have the be equi-spaced but it has to be periodic per quarter note.  #  MusicManipulations.quantize     Function .  quantize ( notes :: Notes ,   grid ,   duration   =   true )  quantize ( note :: AbstractNote ,   grid ,   tpq :: Integer )   Return a quantized copy of the given notes on the given  grid , which can be any sorted iterable that starts on  0  and ends on  1 .  Each note is quantized (relocated) to its closest point of the  grid , by first identifying that point using  classify . It is assumed that the grid is the same for all quarter notes of the track.  If  duration  is  true , the function also quantizes the duration of the notes on the same grid, while ensuring a duration spanning at least one grid point.  This function respects the notes' absolute position and quantizes in absolute position, not relative.   Here are some examples  using   MusicManipulations  midi   =   readMIDIFile ( testmidi ())  notes   =   getnotes ( midi ,   4 )  sixteens   =   0 : 1 // 4 : 1  notes16   =   quantize ( notes ,   sixteens )  swung_8s   =   [ 0 ,   2 // 3 ,   1 ]  swung_notes   =   quantize ( notes ,   swung_8s )   533   Notes   with   tpq = 960 \n  Note   F4    |   vel   =   69    |   pos   =   7360 ,   dur   =   320 \n  Note   A \u266f 4   |   vel   =   85    |   pos   =   7680 ,   dur   =   640 \n  Note   D5    |   vel   =   91    |   pos   =   8320 ,   dur   =   320 \n  Note   D4    |   vel   =   88    |   pos   =   8320 ,   dur   =   320 \n  Note   G \u266f 3   |   vel   =   88    |   pos   =   8320 ,   dur   =   320 \n  Note   A \u266f 4   |   vel   =   76    |   pos   =   8640 ,   dur   =   640 \n  Note   G4    |   vel   =   66    |   pos   =   9280 ,   dur   =   320 \n   \u22ee \n  Note   D5    |   vel   =   91    |   pos   =   189760 ,   dur   =   320 \n  Note   D5    |   vel   =   106   |   pos   =   190720 ,   dur   =   320 \n  Note   A4    |   vel   =   99    |   pos   =   190720 ,   dur   =   320 \n  Note   D \u266f 4   |   vel   =   101   |   pos   =   190720 ,   dur   =   960 \n  Note   A3    |   vel   =   106   |   pos   =   190720 ,   dur   =   960 \n  Note   D4    |   vel   =   106   |   pos   =   190720 ,   dur   =   960 \n  Note   G4    |   vel   =   109   |   pos   =   190720 ,   dur   =   320   The first quantization quantized the notes on the 16-th subdivision. The second one did something a bit more specialized, as it separated the notes to \"quarter notes\" and swung 8th notes, the typical way a Jazz standard (like Serenade To A Cuckoo) is played.", 
            "title": "Quantization"
        }, 
        {
            "location": "/mm/quantizing/#classification", 
            "text": "quantize  works in two steps. In the first step, each note is \"classified\", according to which is the closest grid point to this note (modulo the quarter note).  #  MusicManipulations.classify     Function .  classify ( notes :: Notes ,   grid )  classify ( note :: AbstractNote ,   grid ,   tpq :: Integer )   Classify given notes according to the given grid.  Returns an integer (or vector of integers) that corresponds to the index of the closest grid point to the note position modulo the quarter note.  1  means start of the grid and  length(grid)  means end of the grid (i.e.  next  quarter note).  After the notes have been classified, this classification vector is used to simply relocate all notes to the closest grid point (modulo the quarter note).", 
            "title": "Classification"
        }, 
        {
            "location": "/mm/extraction/", 
            "text": "Music Data Extraction\n\n\nThe functions described in this page allow for easier extraction of data from music recordings (in the form of MIDI). A highlight of JuliaMusic is the \ntimeseries\n function, which allows one to directly get gridded timeseries from arbitrary \nNotes\n structures.\n\n\n\n\nBasic Data Extraction\n\n\n#\n\n\nMusicManipulations.firstnotes\n \n \nFunction\n.\n\n\nfirstnotes\n(\nnotes\n,\n \ngrid\n)\n\n\n\n\n\n\nReturn the notes that first appear in each grid point, \nwithout quantizing them\n.\n\n\nThis function \ndoes not\n consider the notes modulo the quarter note! Different quarter notes have different grid points.\n\n\n#\n\n\nMusicManipulations.allowedpitches\n \n \nFunction\n.\n\n\nallowedpitches\n(\nnotes\n::\nNotes\n,\n \nallowed\n)\n \n-\n \nnewnotes\n\n\n\n\n\n\nOnly keep the notes that have a pitch specified in \nallowed\n (one or many pitches).\n\n\n#\n\n\nMusicManipulations.separatepitches\n \n \nFunction\n.\n\n\nseparatepitches\n(\nnotes\n::\nNotes\n \n[,\n \nallowed\n])\n\n\n\n\n\n\nGet a dictionary \"pitch\"=\n\"notes of that pitch\". Optionally only keep pitches that are contained in \nallowed\n.\n\n\n\n\nTimeseries Extraction\n\n\n#\n\n\nMusicManipulations.timeseries\n \n \nFunction\n.\n\n\ntimeseries\n(\nnotes\n::\nNotes\n,\n \nproperty\n,\n \nf\n,\n \ngrid\n)\n \n-\n \ntvec\n,\n \nts\n\n\n\n\n\n\nProduce a timeseries of the \nproperty\n of the given notes, by first quantizing on the given \ngrid\n (to avoid actual quantization use the grid \n0:1//notes.tpq:1\n). Return the time vector \ntvec\n in ticks and the produced timeseries \nts\n.\n\n\nAfter quantization, it is often the case that many notes are in the same bin of the grid. The \nfunction\n \nf\n denotes which value of the vector of the \nproperty\n of the notes to keep. Typical values are \nminimum, maximum, mean\n, etc. Notice that bins without any note in them obtain the value \nmissing\n, regardless of the function \nf\n or the \nproperty\n.\n\n\nIf the \nproperty\n is \n:velocity\n, \n:pitch\n, or \n:duration\n the function behaves exactly as described. The \nproperty\n can also be \n:position\n. In this case, the timeseries \nts\n contain the timing deviations of the notes with respect to the \ntvec\n vector (these numbers are known as \nmicrotiming deviations\n in the literature.)\n\n\nHere is an example:\n\n\n```@example\nusing MusicManipulations, PyPlot\nmidi = readMIDIFile(testmidi())\nnotes = getnotes(midi, 4)\n\n\nswung_8s = [0, 2//3, 1]\nt, vel = timeseries(notes, :velocity, mean, swung_8s)\n\n\nnotmiss = findall(!ismissing, vel)\n\n\nfig, (ax1, ax2) = subplots(2,1)\nax1.scatter(t[notmiss], vel[notmiss])\nax1.set_ylabel(\"velocity\")\n\n\nt, mtd = timeseries(notes, :position, mean, swung_8s)\nax2.scatter(t[notmiss], mtd[notmiss], color = \"C1\")\nax2.set_ylabel(\"timing deviations\")\nax2.set_xlabel(\"ticks\")\ntight_layout() # hide\nsavefig(\"timeseries.png\"); nothing # hide\n```", 
            "title": "Music Data Extraction"
        }, 
        {
            "location": "/mm/extraction/#music-data-extraction", 
            "text": "The functions described in this page allow for easier extraction of data from music recordings (in the form of MIDI). A highlight of JuliaMusic is the  timeseries  function, which allows one to directly get gridded timeseries from arbitrary  Notes  structures.", 
            "title": "Music Data Extraction"
        }, 
        {
            "location": "/mm/extraction/#basic-data-extraction", 
            "text": "#  MusicManipulations.firstnotes     Function .  firstnotes ( notes ,   grid )   Return the notes that first appear in each grid point,  without quantizing them .  This function  does not  consider the notes modulo the quarter note! Different quarter notes have different grid points.  #  MusicManipulations.allowedpitches     Function .  allowedpitches ( notes :: Notes ,   allowed )   -   newnotes   Only keep the notes that have a pitch specified in  allowed  (one or many pitches).  #  MusicManipulations.separatepitches     Function .  separatepitches ( notes :: Notes   [,   allowed ])   Get a dictionary \"pitch\"= \"notes of that pitch\". Optionally only keep pitches that are contained in  allowed .", 
            "title": "Basic Data Extraction"
        }, 
        {
            "location": "/mm/extraction/#timeseries-extraction", 
            "text": "#  MusicManipulations.timeseries     Function .  timeseries ( notes :: Notes ,   property ,   f ,   grid )   -   tvec ,   ts   Produce a timeseries of the  property  of the given notes, by first quantizing on the given  grid  (to avoid actual quantization use the grid  0:1//notes.tpq:1 ). Return the time vector  tvec  in ticks and the produced timeseries  ts .  After quantization, it is often the case that many notes are in the same bin of the grid. The  function   f  denotes which value of the vector of the  property  of the notes to keep. Typical values are  minimum, maximum, mean , etc. Notice that bins without any note in them obtain the value  missing , regardless of the function  f  or the  property .  If the  property  is  :velocity ,  :pitch , or  :duration  the function behaves exactly as described. The  property  can also be  :position . In this case, the timeseries  ts  contain the timing deviations of the notes with respect to the  tvec  vector (these numbers are known as  microtiming deviations  in the literature.)  Here is an example:  ```@example\nusing MusicManipulations, PyPlot\nmidi = readMIDIFile(testmidi())\nnotes = getnotes(midi, 4)  swung_8s = [0, 2//3, 1]\nt, vel = timeseries(notes, :velocity, mean, swung_8s)  notmiss = findall(!ismissing, vel)  fig, (ax1, ax2) = subplots(2,1)\nax1.scatter(t[notmiss], vel[notmiss])\nax1.set_ylabel(\"velocity\")  t, mtd = timeseries(notes, :position, mean, swung_8s)\nax2.scatter(t[notmiss], mtd[notmiss], color = \"C1\")\nax2.set_ylabel(\"timing deviations\")\nax2.set_xlabel(\"ticks\")\ntight_layout() # hide\nsavefig(\"timeseries.png\"); nothing # hide\n```", 
            "title": "Timeseries Extraction"
        }, 
        {
            "location": "/printplot/musescore/", 
            "text": "Printing into a Score using MuseScore\n\n\nMuseScore\n is a wonderful and open source professional music score editor. \nMusicManipulations\n provides a convenient interface that can instantly print any \nNotes\n or \nMIDIFile\n structure via MuseScore.\n\n\n#\n\n\nMusicManipulations.MuseScore.musescore\n \n \nFunction\n.\n\n\nmusescore\n(\nfile\n,\n \nnotes\n \n|\n \nmidi\n;\n \ndisplay\n \n=\n \ntrue\n,\n \nrmmidi\n \n=\n \nfalse\n)\n\n\n\n\n\n\nUse the open source software \"MuseScore\" to create a score and save the output to \nfile\n. By default it will also display the created \nfile\n, which can be either a \n.pdf\n or a \n.png\n. The function must first create a MIDI file (uses the same name as \nfile\n). You can choose to delete it afterwards (\nrmmidi\n).\n\n\nMuseScore must be accessible from the command line. In Windows try \nMuseScore -v\n to ensure that, otherwise \nmscore -v\n.\n\n\nIf given a \n.png\n the actual file name will end with \n-1\n, \n-2\n etc. for each page of the score. Notice that MuseScore must be accessible from the command line for this function to work.\n\n\n\n\nQuantize your notes!\n\n\nKeep in mind that the score creation capabilities of MuseScore rely upon having well-defined notes. This means that you should use the function \nquantize\n to quantize both the position and duration of your notes!\n\n\n\n\n\n\nCreating a Score out of some Notes\n\n\nusing\n \nMusicManipulations\n\n\n\n\n\n\nWe first load the test MIDI file \"Doxy\". The third track has the notes of the Bass:\n\n\nmidi\n \n=\n \nreadMIDIFile\n()\n \n# read the \ntest\n Doxy MIDI recording.\n\n\nbass\n \n=\n \ngetnotes\n(\nmidi\n,\n \n3\n)\n\n\nbasstrim\n \n=\n \nbass\n[\n1\n:\n50\n]\n\n\n\n\n\n\n50\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nA\n\u266f\n2\n \n|\n \nvel\n \n=\n \n95\n  \n|\n \npos\n \n=\n \n7680\n,\n \ndur\n \n=\n \n690\n\n \nNote\n \nA\n\u266f\n2\n \n|\n \nvel\n \n=\n \n71\n  \n|\n \npos\n \n=\n \n9280\n,\n \ndur\n \n=\n \n308\n\n \nNote\n \nG\n\u266f\n2\n \n|\n \nvel\n \n=\n \n52\n  \n|\n \npos\n \n=\n \n9600\n,\n \ndur\n \n=\n \n668\n\n \nNote\n \nG\n\u266f\n2\n \n|\n \nvel\n \n=\n \n58\n  \n|\n \npos\n \n=\n \n11200\n,\n \ndur\n \n=\n \n338\n\n \nNote\n \nG2\n  \n|\n \nvel\n \n=\n \n71\n  \n|\n \npos\n \n=\n \n11520\n,\n \ndur\n \n=\n \n701\n\n \nNote\n \nG\n\u266f\n2\n \n|\n \nvel\n \n=\n \n83\n  \n|\n \npos\n \n=\n \n13120\n,\n \ndur\n \n=\n \n281\n\n \nNote\n \nG2\n  \n|\n \nvel\n \n=\n \n73\n  \n|\n \npos\n \n=\n \n13440\n,\n \ndur\n \n=\n \n855\n\n  \n\u22ee\n\n \nNote\n \nF2\n  \n|\n \nvel\n \n=\n \n75\n  \n|\n \npos\n \n=\n \n53760\n,\n \ndur\n \n=\n \n885\n\n \nNote\n \nA\n\u266f\n2\n \n|\n \nvel\n \n=\n \n80\n  \n|\n \npos\n \n=\n \n54720\n,\n \ndur\n \n=\n \n930\n\n \nNote\n \nG\n\u266f\n2\n \n|\n \nvel\n \n=\n \n97\n  \n|\n \npos\n \n=\n \n55680\n,\n \ndur\n \n=\n \n889\n\n \nNote\n \nD\n\u266f\n2\n \n|\n \nvel\n \n=\n \n80\n  \n|\n \npos\n \n=\n \n56640\n,\n \ndur\n \n=\n \n930\n\n \nNote\n \nG2\n  \n|\n \nvel\n \n=\n \n80\n  \n|\n \npos\n \n=\n \n57600\n,\n \ndur\n \n=\n \n975\n\n \nNote\n \nB1\n  \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n58560\n,\n \ndur\n \n=\n \n952\n\n \nNote\n \nD2\n  \n|\n \nvel\n \n=\n \n83\n  \n|\n \npos\n \n=\n \n59520\n,\n \ndur\n \n=\n \n941\n\n\n\n\n\n\nBecause the notes of the Bass are already quantized we can already print them into a staff using MuseScore:\n\n\nmusescore\n(\nbass\n,\n \nnotes\n)\n\n\n\n\n\n\n\n\nAmazingly MuseScore deduces automatically the clef and even the key of the piece!\n\n\n\n\nCreating a full Score out of a MIDI file\n\n\nYou can also pass a full MIDI file to \nmusescore\n.\n\n\npiano\n \n=\n \ngetnotes\n(\nmidi\n,\n \n4\n)\n\n\n\n\n\n\n533\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nF4\n  \n|\n \nvel\n \n=\n \n69\n  \n|\n \npos\n \n=\n \n7427\n,\n \ndur\n \n=\n \n181\n\n \nNote\n \nA\n\u266f\n4\n \n|\n \nvel\n \n=\n \n85\n  \n|\n \npos\n \n=\n \n7760\n,\n \ndur\n \n=\n \n450\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n91\n  \n|\n \npos\n \n=\n \n8319\n,\n \ndur\n \n=\n \n356\n\n \nNote\n \nD4\n  \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n8323\n,\n \ndur\n \n=\n \n314\n\n \nNote\n \nG\n\u266f\n3\n \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n8327\n,\n \ndur\n \n=\n \n358\n\n \nNote\n \nA\n\u266f\n4\n \n|\n \nvel\n \n=\n \n76\n  \n|\n \npos\n \n=\n \n8694\n,\n \ndur\n \n=\n \n575\n\n \nNote\n \nG4\n  \n|\n \nvel\n \n=\n \n66\n  \n|\n \npos\n \n=\n \n9281\n,\n \ndur\n \n=\n \n273\n\n  \n\u22ee\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n91\n  \n|\n \npos\n \n=\n \n189794\n,\n \ndur\n \n=\n \n227\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190725\n,\n \ndur\n \n=\n \n610\n\n \nNote\n \nA4\n  \n|\n \nvel\n \n=\n \n99\n  \n|\n \npos\n \n=\n \n190729\n,\n \ndur\n \n=\n \n604\n\n \nNote\n \nD\n\u266f\n4\n \n|\n \nvel\n \n=\n \n101\n \n|\n \npos\n \n=\n \n190742\n,\n \ndur\n \n=\n \n720\n\n \nNote\n \nA3\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190746\n,\n \ndur\n \n=\n \n833\n\n \nNote\n \nD4\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190746\n,\n \ndur\n \n=\n \n837\n\n \nNote\n \nG4\n  \n|\n \nvel\n \n=\n \n109\n \n|\n \npos\n \n=\n \n190748\n,\n \ndur\n \n=\n \n590\n\n\n\n\n\n\nHowever, MuseScore has decent results only with quantized notes. Let's quantize on a triplet grid using \nquantize\n.\n\n\nqpiano\n \n=\n \nquantize\n(\npiano\n,\n \n[\n0\n,\n \n1\n//\n3\n,\n \n2\n//\n3\n,\n \n1\n])\n\n\n\n\n\n\n533\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nF4\n  \n|\n \nvel\n \n=\n \n69\n  \n|\n \npos\n \n=\n \n7360\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nA\n\u266f\n4\n \n|\n \nvel\n \n=\n \n85\n  \n|\n \npos\n \n=\n \n7680\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n91\n  \n|\n \npos\n \n=\n \n8320\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nD4\n  \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n8320\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nG\n\u266f\n3\n \n|\n \nvel\n \n=\n \n88\n  \n|\n \npos\n \n=\n \n8320\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nA\n\u266f\n4\n \n|\n \nvel\n \n=\n \n76\n  \n|\n \npos\n \n=\n \n8640\n,\n \ndur\n \n=\n \n640\n\n \nNote\n \nG4\n  \n|\n \nvel\n \n=\n \n66\n  \n|\n \npos\n \n=\n \n9280\n,\n \ndur\n \n=\n \n320\n\n  \n\u22ee\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n91\n  \n|\n \npos\n \n=\n \n189760\n,\n \ndur\n \n=\n \n320\n\n \nNote\n \nD5\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n640\n\n \nNote\n \nA4\n  \n|\n \nvel\n \n=\n \n99\n  \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n640\n\n \nNote\n \nD\n\u266f\n4\n \n|\n \nvel\n \n=\n \n101\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n640\n\n \nNote\n \nA3\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n960\n\n \nNote\n \nD4\n  \n|\n \nvel\n \n=\n \n106\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n960\n\n \nNote\n \nG4\n  \n|\n \nvel\n \n=\n \n109\n \n|\n \npos\n \n=\n \n190720\n,\n \ndur\n \n=\n \n640\n\n\n\n\n\n\nand save both tracks into a midi file:\n\n\nptrack\n \n=\n \nMIDITrack\n()\n\n\naddnotes!\n(\nptrack\n,\n \nqpiano\n)\n\n\naddtrackname!\n(\nptrack\n,\n \nDoxy\n)\n\n\nsmidi\n \n=\n \nMIDIFile\n(\n1\n,\n \n960\n,\n \n[\nmidi\n.\ntracks\n[\n3\n],\n \nptrack\n])\n\n\n\n\n\n\nMIDIFile\n:\n\n  \nformat\n:\n \n1\n\n  \ntracks\n:\n \n2\n\n  \ntpq\n:\n \n960\n\n\n\n\n\n\nand then save the full thing as \n.pdf\n:\n\n\nmusescore\n(\ndoxy.pdf\n,\n \nsmidi\n)\n\n\n\n\n\n\nYou can find the produced \n.pdf\n file \nhere\n. The first page looks like this: \n When given multiple tracks MuseScore displays the name of the track (\ntrackname\n), as well as the instrument it automatically chose to represent it.\n\n\n\n\nDrum notation\n\n\nTo export directly into drum notation you need to make two changes to your notes:\n\n\n\n\nCreate your notes into channel \n9\n instead of the default \n0\n.\n\n\nUse the appropriate pitches that correspond to the drum instruments. For this you can use the dictionary \nMuseScore.drumkey\n (which follows the GM mapping).\n\n\n\n\nFor example, let's make a standard rock drums pattern:\n\n\nbass\n \n=\n \nMuseScore\n.\ndrumkey\n[\nAcoustic Bass Drum\n]\n\n\nsnare\n \n=\n \nMuseScore\n.\ndrumkey\n[\nAcoustic Snare\n]\n\n\nhihat\n \n=\n \nMuseScore\n.\ndrumkey\n[\nClosed Hi-Hat\n]\n\n\nmidichannel\n \n=\n \n9\n\n\n\ntpq\n \n=\n \n960\n\n\nei\n \n=\n \nsubdivision\n(\n8\n,\n \ntpq\n)\n\n\n\nrock\n \n=\n \n[\nNote\n(\nhihat\n,\n \niseven\n(\ni\n)\n \n?\n \n100\n \n:\n \n60\n,\n \nei\n*\ni\n,\n \nei\n,\n \nmidichannel\n)\n \nfor\n \ni\n \nin\n \n0\n:\n7\n]\n\n\nfor\n \ni\n \nin\n \n1\n:\n2\n\n    \npush!\n(\nrock\n,\n \nNote\n(\nbass\n,\n \n100\n,\n \n4\n(\ni\n-\n1\n)\nei\n,\n \n2\nei\n,\n \nmidichannel\n))\n\n    \npush!\n(\nrock\n,\n \nNote\n(\nsnare\n,\n \n100\n,\n \n4\n(\ni\n-\n1\n)\nei\n \n+\n \n2\nei\n,\n \n2\nei\n,\n \nmidichannel\n))\n\n\nend\n\n\nrock\n \n=\n \nNotes\n(\nrock\n,\n \ntpq\n)\n\n\n\n\n\n\n12\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n0\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n60\n  \n|\n \npos\n \n=\n \n480\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n960\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n60\n  \n|\n \npos\n \n=\n \n1440\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n1920\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n60\n  \n|\n \npos\n \n=\n \n2400\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n2880\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nF\n\u266f\n2\n \n|\n \nvel\n \n=\n \n60\n  \n|\n \npos\n \n=\n \n3360\n,\n \ndur\n \n=\n \n480\n \n|\n \nchannel\n \n9\n\n \nNote\n \nB1\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n0\n,\n \ndur\n \n=\n \n960\n \n|\n \nchannel\n \n9\n\n \nNote\n \nD2\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n960\n,\n \ndur\n \n=\n \n960\n \n|\n \nchannel\n \n9\n\n \nNote\n \nB1\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n1920\n,\n \ndur\n \n=\n \n960\n \n|\n \nchannel\n \n9\n\n \nNote\n \nD2\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n2880\n,\n \ndur\n \n=\n \n960\n \n|\n \nchannel\n \n9\n\n\n\n\n\n\nmusescore\n(\nrock.png\n,\n \nrock\n)", 
            "title": "Printing Notes into Score"
        }, 
        {
            "location": "/printplot/musescore/#printing-into-a-score-using-musescore", 
            "text": "MuseScore  is a wonderful and open source professional music score editor.  MusicManipulations  provides a convenient interface that can instantly print any  Notes  or  MIDIFile  structure via MuseScore.  #  MusicManipulations.MuseScore.musescore     Function .  musescore ( file ,   notes   |   midi ;   display   =   true ,   rmmidi   =   false )   Use the open source software \"MuseScore\" to create a score and save the output to  file . By default it will also display the created  file , which can be either a  .pdf  or a  .png . The function must first create a MIDI file (uses the same name as  file ). You can choose to delete it afterwards ( rmmidi ).  MuseScore must be accessible from the command line. In Windows try  MuseScore -v  to ensure that, otherwise  mscore -v .  If given a  .png  the actual file name will end with  -1 ,  -2  etc. for each page of the score. Notice that MuseScore must be accessible from the command line for this function to work.   Quantize your notes!  Keep in mind that the score creation capabilities of MuseScore rely upon having well-defined notes. This means that you should use the function  quantize  to quantize both the position and duration of your notes!", 
            "title": "Printing into a Score using MuseScore"
        }, 
        {
            "location": "/printplot/musescore/#creating-a-score-out-of-some-notes", 
            "text": "using   MusicManipulations   We first load the test MIDI file \"Doxy\". The third track has the notes of the Bass:  midi   =   readMIDIFile ()   # read the  test  Doxy MIDI recording.  bass   =   getnotes ( midi ,   3 )  basstrim   =   bass [ 1 : 50 ]   50   Notes   with   tpq = 960 \n  Note   A \u266f 2   |   vel   =   95    |   pos   =   7680 ,   dur   =   690 \n  Note   A \u266f 2   |   vel   =   71    |   pos   =   9280 ,   dur   =   308 \n  Note   G \u266f 2   |   vel   =   52    |   pos   =   9600 ,   dur   =   668 \n  Note   G \u266f 2   |   vel   =   58    |   pos   =   11200 ,   dur   =   338 \n  Note   G2    |   vel   =   71    |   pos   =   11520 ,   dur   =   701 \n  Note   G \u266f 2   |   vel   =   83    |   pos   =   13120 ,   dur   =   281 \n  Note   G2    |   vel   =   73    |   pos   =   13440 ,   dur   =   855 \n   \u22ee \n  Note   F2    |   vel   =   75    |   pos   =   53760 ,   dur   =   885 \n  Note   A \u266f 2   |   vel   =   80    |   pos   =   54720 ,   dur   =   930 \n  Note   G \u266f 2   |   vel   =   97    |   pos   =   55680 ,   dur   =   889 \n  Note   D \u266f 2   |   vel   =   80    |   pos   =   56640 ,   dur   =   930 \n  Note   G2    |   vel   =   80    |   pos   =   57600 ,   dur   =   975 \n  Note   B1    |   vel   =   88    |   pos   =   58560 ,   dur   =   952 \n  Note   D2    |   vel   =   83    |   pos   =   59520 ,   dur   =   941   Because the notes of the Bass are already quantized we can already print them into a staff using MuseScore:  musescore ( bass ,   notes )    Amazingly MuseScore deduces automatically the clef and even the key of the piece!", 
            "title": "Creating a Score out of some Notes"
        }, 
        {
            "location": "/printplot/musescore/#creating-a-full-score-out-of-a-midi-file", 
            "text": "You can also pass a full MIDI file to  musescore .  piano   =   getnotes ( midi ,   4 )   533   Notes   with   tpq = 960 \n  Note   F4    |   vel   =   69    |   pos   =   7427 ,   dur   =   181 \n  Note   A \u266f 4   |   vel   =   85    |   pos   =   7760 ,   dur   =   450 \n  Note   D5    |   vel   =   91    |   pos   =   8319 ,   dur   =   356 \n  Note   D4    |   vel   =   88    |   pos   =   8323 ,   dur   =   314 \n  Note   G \u266f 3   |   vel   =   88    |   pos   =   8327 ,   dur   =   358 \n  Note   A \u266f 4   |   vel   =   76    |   pos   =   8694 ,   dur   =   575 \n  Note   G4    |   vel   =   66    |   pos   =   9281 ,   dur   =   273 \n   \u22ee \n  Note   D5    |   vel   =   91    |   pos   =   189794 ,   dur   =   227 \n  Note   D5    |   vel   =   106   |   pos   =   190725 ,   dur   =   610 \n  Note   A4    |   vel   =   99    |   pos   =   190729 ,   dur   =   604 \n  Note   D \u266f 4   |   vel   =   101   |   pos   =   190742 ,   dur   =   720 \n  Note   A3    |   vel   =   106   |   pos   =   190746 ,   dur   =   833 \n  Note   D4    |   vel   =   106   |   pos   =   190746 ,   dur   =   837 \n  Note   G4    |   vel   =   109   |   pos   =   190748 ,   dur   =   590   However, MuseScore has decent results only with quantized notes. Let's quantize on a triplet grid using  quantize .  qpiano   =   quantize ( piano ,   [ 0 ,   1 // 3 ,   2 // 3 ,   1 ])   533   Notes   with   tpq = 960 \n  Note   F4    |   vel   =   69    |   pos   =   7360 ,   dur   =   320 \n  Note   A \u266f 4   |   vel   =   85    |   pos   =   7680 ,   dur   =   320 \n  Note   D5    |   vel   =   91    |   pos   =   8320 ,   dur   =   320 \n  Note   D4    |   vel   =   88    |   pos   =   8320 ,   dur   =   320 \n  Note   G \u266f 3   |   vel   =   88    |   pos   =   8320 ,   dur   =   320 \n  Note   A \u266f 4   |   vel   =   76    |   pos   =   8640 ,   dur   =   640 \n  Note   G4    |   vel   =   66    |   pos   =   9280 ,   dur   =   320 \n   \u22ee \n  Note   D5    |   vel   =   91    |   pos   =   189760 ,   dur   =   320 \n  Note   D5    |   vel   =   106   |   pos   =   190720 ,   dur   =   640 \n  Note   A4    |   vel   =   99    |   pos   =   190720 ,   dur   =   640 \n  Note   D \u266f 4   |   vel   =   101   |   pos   =   190720 ,   dur   =   640 \n  Note   A3    |   vel   =   106   |   pos   =   190720 ,   dur   =   960 \n  Note   D4    |   vel   =   106   |   pos   =   190720 ,   dur   =   960 \n  Note   G4    |   vel   =   109   |   pos   =   190720 ,   dur   =   640   and save both tracks into a midi file:  ptrack   =   MIDITrack ()  addnotes! ( ptrack ,   qpiano )  addtrackname! ( ptrack ,   Doxy )  smidi   =   MIDIFile ( 1 ,   960 ,   [ midi . tracks [ 3 ],   ptrack ])   MIDIFile : \n   format :   1 \n   tracks :   2 \n   tpq :   960   and then save the full thing as  .pdf :  musescore ( doxy.pdf ,   smidi )   You can find the produced  .pdf  file  here . The first page looks like this:   When given multiple tracks MuseScore displays the name of the track ( trackname ), as well as the instrument it automatically chose to represent it.", 
            "title": "Creating a full Score out of a MIDI file"
        }, 
        {
            "location": "/printplot/musescore/#drum-notation", 
            "text": "To export directly into drum notation you need to make two changes to your notes:   Create your notes into channel  9  instead of the default  0 .  Use the appropriate pitches that correspond to the drum instruments. For this you can use the dictionary  MuseScore.drumkey  (which follows the GM mapping).   For example, let's make a standard rock drums pattern:  bass   =   MuseScore . drumkey [ Acoustic Bass Drum ]  snare   =   MuseScore . drumkey [ Acoustic Snare ]  hihat   =   MuseScore . drumkey [ Closed Hi-Hat ]  midichannel   =   9  tpq   =   960  ei   =   subdivision ( 8 ,   tpq )  rock   =   [ Note ( hihat ,   iseven ( i )   ?   100   :   60 ,   ei * i ,   ei ,   midichannel )   for   i   in   0 : 7 ]  for   i   in   1 : 2 \n     push! ( rock ,   Note ( bass ,   100 ,   4 ( i - 1 ) ei ,   2 ei ,   midichannel )) \n     push! ( rock ,   Note ( snare ,   100 ,   4 ( i - 1 ) ei   +   2 ei ,   2 ei ,   midichannel ))  end  rock   =   Notes ( rock ,   tpq )   12   Notes   with   tpq = 960 \n  Note   F \u266f 2   |   vel   =   100   |   pos   =   0 ,   dur   =   480   |   channel   9 \n  Note   F \u266f 2   |   vel   =   60    |   pos   =   480 ,   dur   =   480   |   channel   9 \n  Note   F \u266f 2   |   vel   =   100   |   pos   =   960 ,   dur   =   480   |   channel   9 \n  Note   F \u266f 2   |   vel   =   60    |   pos   =   1440 ,   dur   =   480   |   channel   9 \n  Note   F \u266f 2   |   vel   =   100   |   pos   =   1920 ,   dur   =   480   |   channel   9 \n  Note   F \u266f 2   |   vel   =   60    |   pos   =   2400 ,   dur   =   480   |   channel   9 \n  Note   F \u266f 2   |   vel   =   100   |   pos   =   2880 ,   dur   =   480   |   channel   9 \n  Note   F \u266f 2   |   vel   =   60    |   pos   =   3360 ,   dur   =   480   |   channel   9 \n  Note   B1    |   vel   =   100   |   pos   =   0 ,   dur   =   960   |   channel   9 \n  Note   D2    |   vel   =   100   |   pos   =   960 ,   dur   =   960   |   channel   9 \n  Note   B1    |   vel   =   100   |   pos   =   1920 ,   dur   =   960   |   channel   9 \n  Note   D2    |   vel   =   100   |   pos   =   2880 ,   dur   =   960   |   channel   9   musescore ( rock.png ,   rock )", 
            "title": "Drum notation"
        }, 
        {
            "location": "/motif/basic/", 
            "text": "Motif Sequence Generation\n\n\n#\n\n\nMotifSequenceGenerator\n \n \nModule\n.\n\n\nMotifSequenceGenerator\n\n\n\n\n\n\nThis module generates random sequences of motifs, under the constrain that the sequence has some total length \u2113 so that \nq - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q\n. All main functionality is given by the function \nrandom_sequence\n.\n\n\n#\n\n\nMotifSequenceGenerator.random_sequence\n \n \nFunction\n.\n\n\nrandom_sequence\n(\nmotifs\n::\nVector\n{\nM\n},\n \nq\n,\n \nlimits\n,\n \ntranslate\n,\n \n\u03b4q\n \n=\n \n0\n;\n \nkwargs\n...\n)\n\n\n\n\n\n\nCreate a random sequence of motifs of type \nM\n, under the constraint that the sequence has \"length\" \n\u2113\n \nexactly\n within \nq - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q\n. Return the sequence itself as well as the sequence of indices of \nmotifs\n used to create it. A vector of probabilities \nweights\n can be given as a keyword argument, which then dictates the sampling probability for each entry of \nmotifs\n for the initial sequence created.\n\n\n\"length\" here means an abstracted length defined by the struct \nM\n, based on the \nlimits\n and \ntranslate\n functions. It does \nnot\n refer to the amount of elements!\n\n\nM\n can be anything, given the two functions\n\n\n\n\nlimits(motif)\n : Some function that given the \nmotif\n it returns the \n(start, fine)\n of the the motif in the same units as \nq\n. This function establishes a measure of length, which simply is \nfine - start\n.\n\n\ntranslate(motif, t)\n : Some function that given the \nmotif\n it returns a \nnew\n motif which is translated by \nt\n (either negative or positive), with respect to the same units as \nq\n.\n\n\n\n\nOther Keywords\n\n\nPlease see the source code (use \n@which\n) for a full description of the algorithm.\n\n\n\n\ntries = 5\n : Up to how many initial random sequences are accepted.\n\n\ntaulcut = 2\n : Up to how times an element is dropped from the initial guess.\n\n\nsummands = 3\n : Up to how many motifs may be combined as a sum to complete a sequence.\n\n\n\n\n\n\nSimple Example\n\n\nThis example illustrates how the module \nMotifSequenceGenerator\n works using a simple \nstruct\n. For a more realistic, and much more complex example, see the \nexample using music notes\n.\n\n\n\n\nLet's say that we want to create a random sequence of \"shouts\", which are described by the \nstruct\n\n\nstruct\n \nShout\n\n  \nshout\n::\nString\n\n  \nstart\n::\nInt\n\n\nend\n\n\n\n\n\n\nLet's first create a vector of shouts that will be used as the pool of possible motifs that will create the random sequence:\n\n\nusing\n \nRandom\n\n\nshouts\n \n=\n \n[\nShout\n(\nuppercase\n(\nrandstring\n(\nrand\n(\n3\n:\n5\n))),\n \nrand\n(\n1\n:\n100\n))\n \nfor\n \nk\n \nin\n \n1\n:\n5\n]\n\n\n\n\n\n\n5\n-\nelement\n \nArray\n{\nMain\n.\nex\n-\nshout\n.\nShout\n,\n1\n}\n:\n\n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nIKF2\n,\n \n52\n)\n \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nEY2\n,\n \n33\n)\n  \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nU8Q7\n,\n \n79\n)\n \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nORS\n,\n \n92\n)\n  \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nOHKMZ\n,\n \n17\n)\n\n\n\n\n\n\nNotice that at the moment the values of the \n.start\n field of \nShout\n are irrelevant. \nMotifSequenceGenerator\n will translate all motifs to start point 0 while operating.\n\n\nNow, to create a random sequence, we need to define two concepts:\n\n\nshoutlimits\n(\ns\n::\nShout\n)\n \n=\n \n(\ns\n.\nstart\n,\n \ns\n.\nstart\n \n+\n \nlength\n(\ns\n.\nshout\n)\n \n+\n \n1\n);\n\n\n\nshouttranslate\n(\ns\n::\nShout\n,\n \nn\n)\n \n=\n \nShout\n(\ns\n.\nshout\n,\n \ns\n.\nstart\n \n+\n \nn\n);\n\n\n\n\n\n\nshouttranslate\n \n(\ngeneric\n \nfunction\n \nwith\n \n1\n \nmethod\n)\n\n\n\n\n\n\nThis means that we accept that the temporal length of a \nShout\n is \nlength(s.shout) + 1\n.\n\n\nWe can now create random sequences of shouts that have total length of \nexactly\n \nq\n:\n\n\nusing\n \nMotifSequenceGenerator\n\n\nq\n \n=\n \n30\n\n\nsequence\n,\n \nidxs\n \n=\n \nrandom_sequence\n(\nshouts\n,\n \nq\n,\n \nshoutlimits\n,\n \nshouttranslate\n)\n\n\nsequence\n\n\n\n\n\n\n6\n-\nelement\n \nArray\n{\nMain\n.\nex\n-\nshout\n.\nShout\n,\n1\n}\n:\n\n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nIKF2\n,\n \n0\n)\n  \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nEY2\n,\n \n5\n)\n   \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nOHKMZ\n,\n \n9\n)\n \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nEY2\n,\n \n15\n)\n  \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nIKF2\n,\n \n19\n)\n \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nOHKMZ\n,\n \n24\n)\n\n\n\n\n\n\nsequence\n,\n \nidxs\n \n=\n \nrandom_sequence\n(\nshouts\n,\n \nq\n,\n \nshoutlimits\n,\n \nshouttranslate\n)\n\n\nsequence\n\n\n\n\n\n\n6\n-\nelement\n \nArray\n{\nMain\n.\nex\n-\nshout\n.\nShout\n,\n1\n}\n:\n\n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nORS\n,\n \n0\n)\n  \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nU8Q7\n,\n \n4\n)\n \n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nOHKMZ\n,\n \n9\n)\n\n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nU8Q7\n,\n \n15\n)\n\n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nU8Q7\n,\n \n20\n)\n\n \nMain\n.\nex\n-\nshout\n.\nShout\n(\nIKF2\n,\n \n25\n)\n\n\n\n\n\n\nNotice that it is impossible to create a sequence of length e.g. \n7\n with the above pool. Doing \nrandom_sequence(shouts, 7, shoutlimits, shouttranslate)\n would throw an error.\n\n\n\n\nFloating point lengths\n\n\nThe lengths of the motifs do not have to be integers. When using motifs with floating lengths, it is advised to give a non-0 \n\u03b4q\n to \nrandom_sequence\n. The following example modifies the \nShout\n struct and shows how it can be done with floating length.\n\n\nstruct\n \nFloatShout\n\n  \nshout\n::\nString\n\n  \ndur\n::\nFloat64\n\n  \nstart\n::\nFloat64\n\n\nend\n\n\n\nrs\n(\nx\n)\n \n=\n \nuppercase\n(\nrandstring\n(\nx\n))\n\n\n\nshouts\n \n=\n \n[\nFloatShout\n(\nrs\n(\nrand\n(\n3\n:\n5\n)),\n \nrand\n()\n+\n1\n,\n \nrand\n())\n \nfor\n \nk\n \nin\n \n1\n:\n5\n]\n\n\nshoutlimits\n(\ns\n::\nFloatShout\n)\n \n=\n \n(\ns\n.\nstart\n,\n \ns\n.\nstart\n \n+\n \ns\n.\ndur\n);\n\n\nshouttranslate\n(\ns\n::\nFloatShout\n,\n \nn\n)\n \n=\n \nFloatShout\n(\ns\n.\nshout\n,\n \ns\n.\ndur\n,\n \ns\n.\nstart\n \n+\n \nn\n);\n\n\n\nq\n \n=\n \n10.0\n\n\n\u03b4q\n \n=\n \n1.0\n\n\n\nr\n,\n \ns\n \n=\n \nrandom_sequence\n(\nshouts\n,\n \nq\n,\n \nshoutlimits\n,\n \nshouttranslate\n,\n \n\u03b4q\n)\n\n\n\nr\n\n\n\n\n\n\n7\n-\nelement\n \nArray\n{\nMain\n.\nex\n-\nshout\n.\nFloatShout\n,\n1\n}\n:\n\n \nMain\n.\nex\n-\nshout\n.\nFloatShout\n(\nTCZCH\n,\n \n1\n.\n9293977321310762\n,\n \n0\n.\n0\n)\n               \n \nMain\n.\nex\n-\nshout\n.\nFloatShout\n(\nWCN\n,\n \n1\n.\n6800738303287193\n,\n \n1\n.\n9293977321310762\n)\n  \n \nMain\n.\nex\n-\nshout\n.\nFloatShout\n(\n2QRMK\n,\n \n1\n.\n1473288132605168\n,\n \n3\n.\n6094715624597953\n)\n\n \nMain\n.\nex\n-\nshout\n.\nFloatShout\n(\nYJ82\n,\n \n1\n.\n349513678787482\n,\n \n4\n.\n756800375720312\n)\n   \n \nMain\n.\nex\n-\nshout\n.\nFloatShout\n(\nYJ82\n,\n \n1\n.\n349513678787482\n,\n \n6\n.\n106314054507794\n)\n   \n \nMain\n.\nex\n-\nshout\n.\nFloatShout\n(\nYJ82\n,\n \n1\n.\n349513678787482\n,\n \n7\n.\n455827733295276\n)\n   \n \nMain\n.\nex\n-\nshout\n.\nFloatShout\n(\n2QRMK\n,\n \n1\n.\n1473288132605168\n,\n \n8\n.\n805341412082758\n)\n \n\n\n\n\n\ns\n\n\n\n\n\n\n7\n-\nelement\n \nArray\n{\nInt64\n,\n1\n}\n:\n\n \n2\n\n \n5\n\n \n3\n\n \n1\n\n \n1\n\n \n1\n\n \n3", 
            "title": "Motif Sequence Generation"
        }, 
        {
            "location": "/motif/basic/#motif-sequence-generation", 
            "text": "#  MotifSequenceGenerator     Module .  MotifSequenceGenerator   This module generates random sequences of motifs, under the constrain that the sequence has some total length \u2113 so that  q - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q . All main functionality is given by the function  random_sequence .  #  MotifSequenceGenerator.random_sequence     Function .  random_sequence ( motifs :: Vector { M },   q ,   limits ,   translate ,   \u03b4q   =   0 ;   kwargs ... )   Create a random sequence of motifs of type  M , under the constraint that the sequence has \"length\"  \u2113   exactly  within  q - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q . Return the sequence itself as well as the sequence of indices of  motifs  used to create it. A vector of probabilities  weights  can be given as a keyword argument, which then dictates the sampling probability for each entry of  motifs  for the initial sequence created.  \"length\" here means an abstracted length defined by the struct  M , based on the  limits  and  translate  functions. It does  not  refer to the amount of elements!  M  can be anything, given the two functions   limits(motif)  : Some function that given the  motif  it returns the  (start, fine)  of the the motif in the same units as  q . This function establishes a measure of length, which simply is  fine - start .  translate(motif, t)  : Some function that given the  motif  it returns a  new  motif which is translated by  t  (either negative or positive), with respect to the same units as  q .   Other Keywords  Please see the source code (use  @which ) for a full description of the algorithm.   tries = 5  : Up to how many initial random sequences are accepted.  taulcut = 2  : Up to how times an element is dropped from the initial guess.  summands = 3  : Up to how many motifs may be combined as a sum to complete a sequence.", 
            "title": "Motif Sequence Generation"
        }, 
        {
            "location": "/motif/basic/#simple-example", 
            "text": "This example illustrates how the module  MotifSequenceGenerator  works using a simple  struct . For a more realistic, and much more complex example, see the  example using music notes .   Let's say that we want to create a random sequence of \"shouts\", which are described by the  struct  struct   Shout \n   shout :: String \n   start :: Int  end   Let's first create a vector of shouts that will be used as the pool of possible motifs that will create the random sequence:  using   Random  shouts   =   [ Shout ( uppercase ( randstring ( rand ( 3 : 5 ))),   rand ( 1 : 100 ))   for   k   in   1 : 5 ]   5 - element   Array { Main . ex - shout . Shout , 1 } : \n  Main . ex - shout . Shout ( IKF2 ,   52 )  \n  Main . ex - shout . Shout ( EY2 ,   33 )   \n  Main . ex - shout . Shout ( U8Q7 ,   79 )  \n  Main . ex - shout . Shout ( ORS ,   92 )   \n  Main . ex - shout . Shout ( OHKMZ ,   17 )   Notice that at the moment the values of the  .start  field of  Shout  are irrelevant.  MotifSequenceGenerator  will translate all motifs to start point 0 while operating.  Now, to create a random sequence, we need to define two concepts:  shoutlimits ( s :: Shout )   =   ( s . start ,   s . start   +   length ( s . shout )   +   1 );  shouttranslate ( s :: Shout ,   n )   =   Shout ( s . shout ,   s . start   +   n );   shouttranslate   ( generic   function   with   1   method )   This means that we accept that the temporal length of a  Shout  is  length(s.shout) + 1 .  We can now create random sequences of shouts that have total length of  exactly   q :  using   MotifSequenceGenerator  q   =   30  sequence ,   idxs   =   random_sequence ( shouts ,   q ,   shoutlimits ,   shouttranslate )  sequence   6 - element   Array { Main . ex - shout . Shout , 1 } : \n  Main . ex - shout . Shout ( IKF2 ,   0 )   \n  Main . ex - shout . Shout ( EY2 ,   5 )    \n  Main . ex - shout . Shout ( OHKMZ ,   9 )  \n  Main . ex - shout . Shout ( EY2 ,   15 )   \n  Main . ex - shout . Shout ( IKF2 ,   19 )  \n  Main . ex - shout . Shout ( OHKMZ ,   24 )   sequence ,   idxs   =   random_sequence ( shouts ,   q ,   shoutlimits ,   shouttranslate )  sequence   6 - element   Array { Main . ex - shout . Shout , 1 } : \n  Main . ex - shout . Shout ( ORS ,   0 )   \n  Main . ex - shout . Shout ( U8Q7 ,   4 )  \n  Main . ex - shout . Shout ( OHKMZ ,   9 ) \n  Main . ex - shout . Shout ( U8Q7 ,   15 ) \n  Main . ex - shout . Shout ( U8Q7 ,   20 ) \n  Main . ex - shout . Shout ( IKF2 ,   25 )   Notice that it is impossible to create a sequence of length e.g.  7  with the above pool. Doing  random_sequence(shouts, 7, shoutlimits, shouttranslate)  would throw an error.", 
            "title": "Simple Example"
        }, 
        {
            "location": "/motif/basic/#floating-point-lengths", 
            "text": "The lengths of the motifs do not have to be integers. When using motifs with floating lengths, it is advised to give a non-0  \u03b4q  to  random_sequence . The following example modifies the  Shout  struct and shows how it can be done with floating length.  struct   FloatShout \n   shout :: String \n   dur :: Float64 \n   start :: Float64  end  rs ( x )   =   uppercase ( randstring ( x ))  shouts   =   [ FloatShout ( rs ( rand ( 3 : 5 )),   rand () + 1 ,   rand ())   for   k   in   1 : 5 ]  shoutlimits ( s :: FloatShout )   =   ( s . start ,   s . start   +   s . dur );  shouttranslate ( s :: FloatShout ,   n )   =   FloatShout ( s . shout ,   s . dur ,   s . start   +   n );  q   =   10.0  \u03b4q   =   1.0  r ,   s   =   random_sequence ( shouts ,   q ,   shoutlimits ,   shouttranslate ,   \u03b4q )  r   7 - element   Array { Main . ex - shout . FloatShout , 1 } : \n  Main . ex - shout . FloatShout ( TCZCH ,   1 . 9293977321310762 ,   0 . 0 )                \n  Main . ex - shout . FloatShout ( WCN ,   1 . 6800738303287193 ,   1 . 9293977321310762 )   \n  Main . ex - shout . FloatShout ( 2QRMK ,   1 . 1473288132605168 ,   3 . 6094715624597953 ) \n  Main . ex - shout . FloatShout ( YJ82 ,   1 . 349513678787482 ,   4 . 756800375720312 )    \n  Main . ex - shout . FloatShout ( YJ82 ,   1 . 349513678787482 ,   6 . 106314054507794 )    \n  Main . ex - shout . FloatShout ( YJ82 ,   1 . 349513678787482 ,   7 . 455827733295276 )    \n  Main . ex - shout . FloatShout ( 2QRMK ,   1 . 1473288132605168 ,   8 . 805341412082758 )    s   7 - element   Array { Int64 , 1 } : \n  2 \n  5 \n  3 \n  1 \n  1 \n  1 \n  3", 
            "title": "Floating point lengths"
        }, 
        {
            "location": "/motif/musicexample/", 
            "text": "Music Motif Examples\n\n\nIn this page \nMotifSequenceGenerator\n is applied in a real world case using the function \nrandom_notes_sequence\n:\n\n\n#\n\n\nMusicManipulations.random_notes_sequence\n \n \nFunction\n.\n\n\nrandom_notes_sequence\n(\nmotifs\n::\nVector\n{\nNotes\n{\nN\n}},\n \nq\n,\n \n\u03b4q\n \n=\n \n0\n;\n \nweights\n)\n\n\n\n\n\n\nCreate a random sequence from a pool of notes (\nmotifs\n) such that it has total length \n\u2113\n exactly \nq - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q\n. Notice that \nq\n is measured in \nticks\n. Optionally pass keyword \nweights\n to sample different motifs with different weights (either as frequencies or as probabilities).\n\n\nReturn the result as a single \nNotes\n container, and also return the sequence of motifs used.\n\n\nThis function uses \nrandom_sequence\n from the module \nMotifSequenceGenerator\n, adapted to the \nNotes\n struct.\n\n\n\n\nMotifs: Basic drum patterns\n\n\nLet's say that we have some basic drum patterns that we want to be able to combine freely at random combinations. For example,\n\n\n\n\nwhere the note E means right hand, while A means left hand. These patterns can be easily combined to fill a bar, like for example \n5b -\n 5b -\n 3 -\n 3\n or \n5a -\n 4 -\n 4 -\n 3\n, etc. They can also be combined to fill two bars and so on. Notice that some sequences, like e.g. the \n5a -\n 4 -\n 4 -\n 3\n, result in \nalternating hands\n: each time the sequence is played the hand that \"leads\" is swapped. This will be important later on.\n\n\nThe goal is to be able to play arbitrary sequences of them for arbitrary lengths. How does one practice that? We will use \nrandom_notes_sequence\n to create longer 8-bar sequences faster with the help of Julia.\n\n\n\n\nDefining the \nNotes\n\n\nWe first have to define the \nNotes\n instances that will correspond to those four basic patterns.\n\n\nusing\n \nMusicManipulations\n \n# re-exports MIDI\n\n\n\ntpq\n \n=\n \n960\n \n# ticks per quarter note\n\n\nsixt\n \n=\n \n240\n \n# duration of sixteenth note\n\n\nleft\n \n=\n \nname_to_pitch\n(\nA5\n)\n\n\nright\n \n=\n \nname_to_pitch\n(\nE6\n)\n\n\n\n\n\n\n88\n\n\n\n\n\n\nReminder: \nNote(pitch, intensity, start, duration)\n\n\nmotif1\n \n=\n \n[\n \n# motif 5a\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n100\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n3\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n4\nsixt\n,\n \nsixt\n)\n\n\n]\n\n\n\nmotif2\n \n=\n \n[\n \n# motif 5b\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n3\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n4\nsixt\n,\n \nsixt\n)\n\n\n]\n\n\n\nmotif3\n \n=\n \n[\n \n# motif 3\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\n]\n\n\n\nmotif4\n \n=\n \n[\n \n# motif 4\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n3\nsixt\n,\n \nsixt\n),\n\n\n]\n\n\n\nmotifs\n \n=\n \nNotes\n.\n([\nmotif1\n,\n \nmotif2\n,\n \nmotif3\n,\n \nmotif4\n],\n \ntpq\n)\n\n\n\n\n\n\n4\n-\nelement\n \nArray\n{\nNotes\n{\nNote\n}\n,\n1\n}\n:\n\n \nNotes\n{\nNote\n}\n \nwith\n \n5\n \nnotes\n\n \nNotes\n{\nNote\n}\n \nwith\n \n5\n \nnotes\n\n \nNotes\n{\nNote\n}\n \nwith\n \n3\n \nnotes\n\n \nNotes\n{\nNote\n}\n \nwith\n \n4\n \nnotes\n\n\n\n\n\n\nNow \nmotifs\n stands for a pool of note sequences we can draw random samples from. Let's generate sequences that are 8-bars long (i.e. 32 quarter notes)\n\n\nq\n \n=\n \ntpq\n*\n32\n\n\n\nnotes\n,\n \nseq\n \n=\n \nrandom_notes_sequence\n(\nmotifs\n,\n \nq\n)\n\n\nnotes\n\n\n\n\n\n\n128\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n0\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n240\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n480\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n720\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n960\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n1200\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n1440\n,\n \ndur\n \n=\n \n240\n\n  \n\u22ee\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n29040\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n29280\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n29520\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n29760\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n30000\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n30240\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n30480\n,\n \ndur\n \n=\n \n240\n\n\n\n\n\n\nand now we can write these to a MIDI file simply by doing \nwriteMIDIFile(\"drums_patterns.mid\", notes)\n if we want to. We can also use \nMuseScore\n, to visualize and print the result. The function \nmusescore\n provides this interface.\n\n\nmusescore\n(\ndrums_patterns.png\n,\n \nnotes\n)\n\n\n\n\n\n\n\n\nthis is a pre-made figure - your random sequence will probably differ\n\n\nThis worked nicely, but there is a problem: The sequence does not respect the fact that some specific patterns (\n5b\n and \n4\n) swap the leading hand. This is what we tackle in the next section.\n\n\n\n\nAdding alternating hands and Lyrics\n\n\nNotice that \nrandom_note_sequence\n also returns the indices of the motifs that were used to create the sequence:\n\n\nseq\n\n\n\n\n\n\n29\n-\nelement\n \nArray\n{\nInt64\n,\n1\n}\n:\n\n \n1\n\n \n1\n\n \n1\n\n \n4\n\n \n1\n\n \n3\n\n \n1\n\n \n1\n\n \n4\n\n \n3\n\n \n\u22ee\n\n \n1\n\n \n3\n\n \n1\n\n \n2\n\n \n4\n\n \n1\n\n \n1\n\n \n3\n\n \n1\n\n\n\n\n\n\nWe can use this information to put the correct \"stickings\". To alternate hands we simply need to replace the necessary E notes with A and vice versa. Let's define some \"meta-data\" like structures\n\n\naccent1\n \n=\n \n(\n5a\n,\n \nfalse\n)\n\n\naccent2\n \n=\n \n(\n5b\n,\n \ntrue\n)\n\n\naccent3\n \n=\n \n(\n3\n,\n \nfalse\n)\n\n\naccent4\n \n=\n \n(\n4\n,\n \ntrue\n)\n\n\naccents\n \n=\n \n[\naccent1\n,\n \naccent2\n,\n \naccent3\n,\n \naccent4\n]\n\n\n\n\n\n\n4\n-\nelement\n \nArray\n{\nTuple\n{\nString\n,\nBool\n}\n,\n1\n}\n:\n\n \n(\n5a\n,\n \nfalse\n)\n\n \n(\n5b\n,\n \ntrue\n)\n \n \n(\n3\n,\n \nfalse\n)\n \n \n(\n4\n,\n \ntrue\n)\n  \n\n\n\n\n\nThe first entry of each tuple is simply the name of the pattern which we will also show in our music score as \"lyrics\". The second entry of the tuple simply denotes whether the pattern swaps the leading hand.\n\n\nThe function that will \"inverse\" a note sticking is:\n\n\ninverse!\n(\nn\n::\nNote\n)\n \n=\n \n(\nn\n.\npitch\n \n=\n \n(\nn\n.\npitch\n \n==\n \nleft\n \n?\n \nright\n \n:\n \nleft\n));\n\n\n\n\n\n\ninverse\n!\n \n(\ngeneric\n \nfunction\n \nwith\n \n1\n \nmethod\n)\n\n\n\n\n\n\nThe function that will \"count\" how long is each pattern, so that we put the lyrics on the correct positions in the score, will be:\n\n\nnote_length\n(\ns\n::\nString\n)\n \n=\n \nparse\n(\nInt\n,\n \ns\n[\n1\n]);\n\n\n\n\n\n\nnote_length\n \n(\ngeneric\n \nfunction\n \nwith\n \n1\n \nmethod\n)\n\n\n\n\n\n\n(remember: \nsixt\n is the duration of one sixteenth note). We now initialize an empty \nMIDITrack\n and add all events to it!\n\n\ntrack\n \n=\n \nMIDITrack\n()\n\n\n\u2113\n \n=\n \n0\n\n\nright_leads\n \n=\n \ntrue\n\n\n\nfor\n \ni\n \nin\n \n1\n:\nlength\n(\nseq\n)\n\n\n    \ns\n \n=\n \naccents\n[\nseq\n[\ni\n]][\n1\n]\n\n    \nle\n \n=\n \ntextevent\n(\n:\nlyric\n,\n \ns\n)\n\n    \naddevent!\n(\ntrack\n,\n \n\u2113\n*\nsixt\n,\n \nle\n)\n\n\n    \nif\n \n!\nright_leads\n \n# Invert notes\n\n        \nfor\n \nj\n \nin\n \n\u2113\n+\n1\n:\n\u2113\n+\nnote_length\n(\ns\n)\n\n            \ninverse!\n(\nnotes\n[\nj\n])\n\n        \nend\n\n    \nend\n\n\n    \nglobal\n \n\u2113\n \n+=\n \nnote_length\n(\ns\n)\n\n\n    \nchange\n \n=\n \naccents\n[\nseq\n[\ni\n]][\n2\n]\n\n    \nglobal\n \nright_leads\n \n=\n \nxor\n(\nright_leads\n,\n \nchange\n)\n\n\nend\n\n\n\naddnotes!\n(\ntrack\n,\n \nnotes\n)\n\n\nnotes\n\n\n\n\n\n\n128\n \nNotes\n \nwith\n \ntpq\n=\n960\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n0\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n240\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n480\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n720\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n960\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n1200\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n1440\n,\n \ndur\n \n=\n \n240\n\n  \n\u22ee\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n29040\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n29280\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n29520\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n29760\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nA5\n  \n|\n \nvel\n \n=\n \n100\n \n|\n \npos\n \n=\n \n30000\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n30240\n,\n \ndur\n \n=\n \n240\n\n \nNote\n \nE6\n  \n|\n \nvel\n \n=\n \n50\n  \n|\n \npos\n \n=\n \n30480\n,\n \ndur\n \n=\n \n240\n\n\n\n\n\n\nFinally, to visualize, we use \nmusescore\n again, using a midi file as an input\n\n\nmusescore\n(\ndrums_patterns_with_names.png\n,\n \nMIDIFile\n(\n1\n,\n \n960\n,\n \n[\ntrack\n]))\n\n\n\n\n\n\n\n\nIsn't it cool that even the lyrics text was displayed so seamlessly?", 
            "title": "Music Motifs Example"
        }, 
        {
            "location": "/motif/musicexample/#music-motif-examples", 
            "text": "In this page  MotifSequenceGenerator  is applied in a real world case using the function  random_notes_sequence :  #  MusicManipulations.random_notes_sequence     Function .  random_notes_sequence ( motifs :: Vector { Notes { N }},   q ,   \u03b4q   =   0 ;   weights )   Create a random sequence from a pool of notes ( motifs ) such that it has total length  \u2113  exactly  q - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q . Notice that  q  is measured in  ticks . Optionally pass keyword  weights  to sample different motifs with different weights (either as frequencies or as probabilities).  Return the result as a single  Notes  container, and also return the sequence of motifs used.  This function uses  random_sequence  from the module  MotifSequenceGenerator , adapted to the  Notes  struct.", 
            "title": "Music Motif Examples"
        }, 
        {
            "location": "/motif/musicexample/#motifs-basic-drum-patterns", 
            "text": "Let's say that we have some basic drum patterns that we want to be able to combine freely at random combinations. For example,   where the note E means right hand, while A means left hand. These patterns can be easily combined to fill a bar, like for example  5b -  5b -  3 -  3  or  5a -  4 -  4 -  3 , etc. They can also be combined to fill two bars and so on. Notice that some sequences, like e.g. the  5a -  4 -  4 -  3 , result in  alternating hands : each time the sequence is played the hand that \"leads\" is swapped. This will be important later on.  The goal is to be able to play arbitrary sequences of them for arbitrary lengths. How does one practice that? We will use  random_notes_sequence  to create longer 8-bar sequences faster with the help of Julia.", 
            "title": "Motifs: Basic drum patterns"
        }, 
        {
            "location": "/motif/musicexample/#defining-the-notes", 
            "text": "We first have to define the  Notes  instances that will correspond to those four basic patterns.  using   MusicManipulations   # re-exports MIDI  tpq   =   960   # ticks per quarter note  sixt   =   240   # duration of sixteenth note  left   =   name_to_pitch ( A5 )  right   =   name_to_pitch ( E6 )   88   Reminder:  Note(pitch, intensity, start, duration)  motif1   =   [   # motif 5a  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( right ,   100 ,   2 sixt ,   sixt ),  Note ( left ,   50 ,   3 sixt ,   sixt ),  Note ( left ,   50 ,   4 sixt ,   sixt )  ]  motif2   =   [   # motif 5b  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( left ,   50 ,   2 sixt ,   sixt ),  Note ( right ,   50 ,   3 sixt ,   sixt ),  Note ( right ,   50 ,   4 sixt ,   sixt )  ]  motif3   =   [   # motif 3  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( left ,   50 ,   2 sixt ,   sixt ),  ]  motif4   =   [   # motif 4  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( right ,   50 ,   2 sixt ,   sixt ),  Note ( right ,   50 ,   3 sixt ,   sixt ),  ]  motifs   =   Notes . ([ motif1 ,   motif2 ,   motif3 ,   motif4 ],   tpq )   4 - element   Array { Notes { Note } , 1 } : \n  Notes { Note }   with   5   notes \n  Notes { Note }   with   5   notes \n  Notes { Note }   with   3   notes \n  Notes { Note }   with   4   notes   Now  motifs  stands for a pool of note sequences we can draw random samples from. Let's generate sequences that are 8-bars long (i.e. 32 quarter notes)  q   =   tpq * 32  notes ,   seq   =   random_notes_sequence ( motifs ,   q )  notes   128   Notes   with   tpq = 960 \n  Note   E6    |   vel   =   100   |   pos   =   0 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   240 ,   dur   =   240 \n  Note   E6    |   vel   =   100   |   pos   =   480 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   720 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   960 ,   dur   =   240 \n  Note   E6    |   vel   =   100   |   pos   =   1200 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   1440 ,   dur   =   240 \n   \u22ee \n  Note   A5    |   vel   =   50    |   pos   =   29040 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   29280 ,   dur   =   240 \n  Note   E6    |   vel   =   100   |   pos   =   29520 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   29760 ,   dur   =   240 \n  Note   E6    |   vel   =   100   |   pos   =   30000 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   30240 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   30480 ,   dur   =   240   and now we can write these to a MIDI file simply by doing  writeMIDIFile(\"drums_patterns.mid\", notes)  if we want to. We can also use  MuseScore , to visualize and print the result. The function  musescore  provides this interface.  musescore ( drums_patterns.png ,   notes )    this is a pre-made figure - your random sequence will probably differ  This worked nicely, but there is a problem: The sequence does not respect the fact that some specific patterns ( 5b  and  4 ) swap the leading hand. This is what we tackle in the next section.", 
            "title": "Defining the Notes"
        }, 
        {
            "location": "/motif/musicexample/#adding-alternating-hands-and-lyrics", 
            "text": "Notice that  random_note_sequence  also returns the indices of the motifs that were used to create the sequence:  seq   29 - element   Array { Int64 , 1 } : \n  1 \n  1 \n  1 \n  4 \n  1 \n  3 \n  1 \n  1 \n  4 \n  3 \n  \u22ee \n  1 \n  3 \n  1 \n  2 \n  4 \n  1 \n  1 \n  3 \n  1   We can use this information to put the correct \"stickings\". To alternate hands we simply need to replace the necessary E notes with A and vice versa. Let's define some \"meta-data\" like structures  accent1   =   ( 5a ,   false )  accent2   =   ( 5b ,   true )  accent3   =   ( 3 ,   false )  accent4   =   ( 4 ,   true )  accents   =   [ accent1 ,   accent2 ,   accent3 ,   accent4 ]   4 - element   Array { Tuple { String , Bool } , 1 } : \n  ( 5a ,   false ) \n  ( 5b ,   true )  \n  ( 3 ,   false )  \n  ( 4 ,   true )     The first entry of each tuple is simply the name of the pattern which we will also show in our music score as \"lyrics\". The second entry of the tuple simply denotes whether the pattern swaps the leading hand.  The function that will \"inverse\" a note sticking is:  inverse! ( n :: Note )   =   ( n . pitch   =   ( n . pitch   ==   left   ?   right   :   left ));   inverse !   ( generic   function   with   1   method )   The function that will \"count\" how long is each pattern, so that we put the lyrics on the correct positions in the score, will be:  note_length ( s :: String )   =   parse ( Int ,   s [ 1 ]);   note_length   ( generic   function   with   1   method )   (remember:  sixt  is the duration of one sixteenth note). We now initialize an empty  MIDITrack  and add all events to it!  track   =   MIDITrack ()  \u2113   =   0  right_leads   =   true  for   i   in   1 : length ( seq ) \n\n     s   =   accents [ seq [ i ]][ 1 ] \n     le   =   textevent ( : lyric ,   s ) \n     addevent! ( track ,   \u2113 * sixt ,   le ) \n\n     if   ! right_leads   # Invert notes \n         for   j   in   \u2113 + 1 : \u2113 + note_length ( s ) \n             inverse! ( notes [ j ]) \n         end \n     end \n\n     global   \u2113   +=   note_length ( s ) \n\n     change   =   accents [ seq [ i ]][ 2 ] \n     global   right_leads   =   xor ( right_leads ,   change )  end  addnotes! ( track ,   notes )  notes   128   Notes   with   tpq = 960 \n  Note   E6    |   vel   =   100   |   pos   =   0 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   240 ,   dur   =   240 \n  Note   E6    |   vel   =   100   |   pos   =   480 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   720 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   960 ,   dur   =   240 \n  Note   E6    |   vel   =   100   |   pos   =   1200 ,   dur   =   240 \n  Note   A5    |   vel   =   50    |   pos   =   1440 ,   dur   =   240 \n   \u22ee \n  Note   E6    |   vel   =   50    |   pos   =   29040 ,   dur   =   240 \n  Note   E6    |   vel   =   50    |   pos   =   29280 ,   dur   =   240 \n  Note   A5    |   vel   =   100   |   pos   =   29520 ,   dur   =   240 \n  Note   E6    |   vel   =   50    |   pos   =   29760 ,   dur   =   240 \n  Note   A5    |   vel   =   100   |   pos   =   30000 ,   dur   =   240 \n  Note   E6    |   vel   =   50    |   pos   =   30240 ,   dur   =   240 \n  Note   E6    |   vel   =   50    |   pos   =   30480 ,   dur   =   240   Finally, to visualize, we use  musescore  again, using a midi file as an input  musescore ( drums_patterns_with_names.png ,   MIDIFile ( 1 ,   960 ,   [ track ]))    Isn't it cool that even the lyrics text was displayed so seamlessly?", 
            "title": "Adding alternating hands and Lyrics"
        }
    ]
}