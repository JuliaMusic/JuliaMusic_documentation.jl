var documenterSearchIndex = {"docs":
[{"location":"mm/quantizing/#Quantizing-1","page":"Quantizing","title":"Quantizing","text":"","category":"section"},{"location":"mm/quantizing/#Quantization-1","page":"Quantizing","title":"Quantization","text":"","category":"section"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"Quantization is the process of moving all note starting positions to a specified and periodic grid. This \"grid\" does not have the be equi-spaced but it has to be periodic per quarter note.","category":"page"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"quantize","category":"page"},{"location":"mm/quantizing/#MusicManipulations.quantize","page":"Quantizing","title":"MusicManipulations.quantize","text":"quantize(notes::Notes, grid, duration = true)\nquantize(note::AbstractNote, grid, tpq::Integer)\n\nReturn a quantized copy of the given notes on the given grid, which can be any sorted iterable that starts on 0 and ends on 1.\n\nEach note is quantized (relocated) to its closest point of the grid, by first identifying that point using classify. It is assumed that the grid is the same for all quarter notes of the track.\n\nIf duration is true, the function also quantizes the duration of the notes on the same grid, while ensuring a duration spanning at least one grid point.\n\nThis function respects the notes' absolute position and quantizes in absolute position, not relative.\n\n\n\n\n\n","category":"function"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"","category":"page"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"Here are some examples","category":"page"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"using MusicManipulations\nmidi = readMIDIFile(testmidi())\nnotes = getnotes(midi, 4)\n\nsixteens = 0:1//4:1\n\nnotes16 = quantize(notes, sixteens)\n\nswung_8s = [0, 2//3, 1]\n\nswung_notes = quantize(notes, swung_8s)","category":"page"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"The first quantization quantized the notes on the 16-th subdivision. The second one did something a bit more specialized, as it separated the notes to \"quarter notes\" and swung 8th notes, the typical way a Jazz standard (like Serenade To A Cuckoo) is played.","category":"page"},{"location":"mm/quantizing/#Classification-1","page":"Quantizing","title":"Classification","text":"","category":"section"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"quantize works in two steps. In the first step, each note is \"classified\", according to which is the closest grid point to this note (modulo the quarter note).","category":"page"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"classify","category":"page"},{"location":"mm/quantizing/#MusicManipulations.classify","page":"Quantizing","title":"MusicManipulations.classify","text":"classify(notes::Notes, grid)\nclassify(note::AbstractNote, grid, tpq::Integer)\n\nClassify given notes according to the given grid.\n\nReturns an integer (or vector of integers) that corresponds to the index of the closest grid point to the note position modulo the quarter note. 1 means start of the grid and length(grid) means end of the grid (i.e. next quarter note).\n\n\n\n\n\n","category":"function"},{"location":"mm/quantizing/#","page":"Quantizing","title":"Quantizing","text":"After the notes have been classified, this classification vector is used to simply relocate all notes to the closest grid point (modulo the quarter note).","category":"page"},{"location":"midi/notes/#Notes-1","page":"Notes","title":"Notes","text":"","category":"section"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"Note information in MIDI files is typically encoded using NOTEON and NOTEOFF events. A music note however contains more information besides the start and end; we bundle this information into the types Note and Notes. These two structures are central to the way JuliaMusic operates. In addition, all note events of a MIDITrack can be obtained with the function getnotes.","category":"page"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"Note\nNotes\ngetnotes","category":"page"},{"location":"midi/notes/#MIDI.Note","page":"Notes","title":"MIDI.Note","text":"Note <: AbstractNote\n\nMutable data structure describing a \"music note\". A bundle of many notes results in the Notes struct, which is the output of the getnotes function.\n\nFields:\n\npitch::UInt8 : Pitch, starting from C-1 = 0, adding one per semitone. Use the functions name_to_pitch and pitch_to_name for integer and string representations.\nvelocity::UInt8 : Dynamic intensity. Cannot be higher than 127 (0x7F).\nposition::UInt : Position in absolute time (since beginning of track), in ticks.\nduration::UInt : Duration in ticks.\nchannel::UInt8 = 0 : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).\n\nIf the channel of the note is 0 (default) it is not printed with show.\n\n\n\n\n\n","category":"type"},{"location":"midi/notes/#MIDI.Notes","page":"Notes","title":"MIDI.Notes","text":"Notes{N<:AbstractNote}\n\nData structure describing a collection of \"music notes\", bundled with a ticks per quarter note measure.\n\nFields:\n\nnotes::Vector{N} where {N <: Notes}\ntpq::Int16 : Ticks per quarter note. Defines the fundamental unit of measurement  of a note's position and duration, as well as the length of one quarter note.  Takes values from 1 to 960.\n\nNotes is iterated and accessed as if iterating or accessing its field notes.\n\n\n\n\n\n","category":"type"},{"location":"midi/notes/#MIDI.getnotes","page":"Notes","title":"MIDI.getnotes","text":"getnotes(midi::MIDIFile [, trackno])\n\nFind all NOTEON and NOTEOFF midi events in the trackno track of a midi (default 1 or 2), that correspond to the same note value (pitch) and convert them into the Note datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity, but getnotes takes care of this.\n\nNotice that the first track of a midi typically doesn't have any notes, which is why the function defaults to track 2.\n\ngetnotes(track::MIDITrack, tpq = 960)\n\nFind the notes from track directly, passing also the ticks per quarter note.\n\nReturns: Notes{Note}, setting the ticks per quarter note as tpq. You can find the originally exported ticks per quarter note from the original MIDIFile through midi.tpq.\n\n\n\n\n\n","category":"function"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"","category":"page"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"If you have some notes and you want to add them to a track, use","category":"page"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"addnotes!","category":"page"},{"location":"midi/notes/#MIDI.addnotes!","page":"Notes","title":"MIDI.addnotes!","text":"addnotes!(track::MIDITrack, notes)\n\nAdd given notes to given track, internally doing all translations from absolute time to relative time.\n\n\n\n\n\n","category":"function"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"","category":"page"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"Finally, you can use the function getnotnotes(track) to get all TrackEvents that are not NOTEON or NOTEOFF.","category":"page"},{"location":"midi/notes/#Write-Example-1","page":"Notes","title":"Write Example","text":"","category":"section"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"using MIDI\nC = Note(60, 96, 0, 192)\nE = Note(64, 96, 48, 144)\nG = Note(67, 96, 96, 96)\n\ninc = 192\nfile = MIDIFile()\ntrack = MIDITrack()\nnotes = Notes() # tpq automatically = 960\n\npush!(notes, C)\npush!(notes, E)\npush!(notes, G)\n\n# Notes one octave higher\nC = Note(60 + 12, 96, C.position+inc, 192)\nE = Note(64 + 12, 96, E.position+inc, 144)\nG = Note(67 + 12, 96, G.position+inc, 96)\n\naddnotes!(track, notes)\naddtrackname!(track, \"simple track\")\npush!(file.tracks, track)\nwriteMIDIFile(\"test.mid\", file)","category":"page"},{"location":"midi/notes/#Read-Example-1","page":"Notes","title":"Read Example","text":"","category":"section"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"using MIDI\nmidi = readMIDIFile(testmidi())","category":"page"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"# Track number 3 is a quantized bass MIDI track\nbass = midi.tracks[3]\nnotes = getnotes(bass, midi.tpq)\nprintln(\"Notes of track $(trackname(bass)):\")\nnotes","category":"page"},{"location":"midi/notes/#Pitch-to-Int-convertion-1","page":"Notes","title":"Pitch to Int convertion","text":"","category":"section"},{"location":"midi/notes/#","page":"Notes","title":"Notes","text":"name_to_pitch\npitch_to_name\nnote_to_fundamental","category":"page"},{"location":"midi/notes/#MIDI.name_to_pitch","page":"Notes","title":"MIDI.name_to_pitch","text":"name_to_pitch(p::String) -> Int\n\nReturn the pitch value of the given note name p, which can be of the form capital_letter*sharp*octave where:\n\ncapital_letter : from \"A\" to \"G\".\nsharp : one of \"#\" \"♯\" or \"\".\noctave : any integer (as a string), the octave number (an octave is 12 pitches). If not given it is assumed \"5\".\n\nWe define E.g. name_to_pitch(\"C4\") === 60 (i.e. string \"C4\", representing the middle-C, corresponds to pitch 60).\n\nSee http://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/C(musicalnote) .\n\n\n\n\n\n","category":"function"},{"location":"midi/notes/#MIDI.pitch_to_name","page":"Notes","title":"MIDI.pitch_to_name","text":"pitch_to_name(pitch) -> string\n\nReturn the name of the pitch, e.g. F5, A♯3 etc. in modern notation given the pitch value in integer.\n\nReminder: middle C has pitch 60 and is displayed as C4.\n\n\n\n\n\n","category":"function"},{"location":"midi/notes/#MusicManipulations.note_to_fundamental","page":"Notes","title":"MusicManipulations.note_to_fundamental","text":"note_to_fundamental(note(s))\n\nReturn a String or Vector{String} with the fundamental pitch of the notes (i.e. without the octave information).\n\n\n\n\n\n","category":"function"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"EditURL = \"https://github.com/JuliaMusic/JuliaMusic_documentation.jl/blob/master/docs/src/printplot/musescore.jl\"","category":"page"},{"location":"printplot/musescore/#Printing-into-a-Score-using-MuseScore-1","page":"Printing notes into a score","title":"Printing into a Score using MuseScore","text":"","category":"section"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"MuseScore is a wonderful and open source professional music score editor with a huge amount of capabilities. MusicManipulations provides a convenient interface that can instantly print any Notes or MIDIFile structure via MuseScore.","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"musescore","category":"page"},{"location":"printplot/musescore/#MusicVisualizations.musescore","page":"Printing notes into a score","title":"MusicVisualizations.musescore","text":"musescore(file, notes | midi; keywords...)\n\nUse the open source software \"MuseScore\" to create a score and save the given notes (or an entire midi file) to file, which can be either a .pdf or a .png.If given a .png the actual file name will end with -1, -2 etc. for each page of the score.\n\nMuseScore must be accessible from the command line for this to work (add the path to MuseScore.exe to your PATH environment variable (ask Google)).\n\nThe keyword display = true will also display the created file. Keyword rmmidi = true deletes the MIDI file that has to be created inbetween score convertion (use false to keep it). MuseScore is run by default with commands c =-n -T 10 -r 1200`, but you can change the keywordc` to be whatever you want, see the command line options of MuseScore for details.\n\n\n\n\n\n","category":"function"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"tip: Quantize your notes!\nKeep in mind that the score creation capabilities of MuseScore rely upon having well-defined notes. This means that you should use the function quantize to quantize both the position and duration of your notes!","category":"page"},{"location":"printplot/musescore/#Creating-a-Score-out-of-some-Notes-1","page":"Printing notes into a score","title":"Creating a Score out of some Notes","text":"","category":"section"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"using MusicManipulations # tools for manipulating notes in Julia\nusing MusicVisualizations # tools for visualizing these notes","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"We first load the test MIDI file \"Doxy\". The third track has the notes of the Bass:","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"midi = readMIDIFile() # read the \"test\" Doxy MIDI recording.\nbass = getnotes(midi, 3)\nbasstrim = bass[1:50]","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"Because the notes of the Bass are already quantized we can already print them into a staff using MuseScore:","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"musescore(\"bass.png\", basstrim)","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"musescore(\"bass.png\", basstrim)","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"(Image: Bass score)","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"Amazingly MuseScore deduces automatically the clef and even the key of the piece!","category":"page"},{"location":"printplot/musescore/#Creating-a-full-Score-out-of-a-MIDI-file-1","page":"Printing notes into a score","title":"Creating a full Score out of a MIDI file","text":"","category":"section"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"You can also pass a full MIDI file to musescore.","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"piano = getnotes(midi, 4)","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"However, MuseScore has decent results only with quantized notes. Let's quantize on a triplet grid using quantize.","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"qpiano = quantize(piano, [0, 1//3, 2//3, 1])","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"and save both tracks into a midi file:","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"ptrack = MIDITrack()\naddnotes!(ptrack, qpiano)\naddtrackname!(ptrack, \"Doxy\")\nsmidi = MIDIFile(1, 960, [midi.tracks[3], ptrack])","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"and then save the full thing as .pdf or .png:","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"musescore(\"doxy.png\", smidi)","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"The first page looks like this: (Image: Full score)","category":"page"},{"location":"printplot/musescore/#","page":"Printing notes into a score","title":"Printing notes into a score","text":"When given multiple tracks MuseScore displays the name of the track (trackname), as well as the instrument it automatically chose to represent it.","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"EditURL = \"https://github.com/JuliaMusic/JuliaMusic_documentation.jl/blob/master/docs/src/blog/drumpatterns.jl\"","category":"page"},{"location":"blog/drumpatterns/#Mixing-basic-drum-patterns-1","page":"Ep. 1 - Mixing drum patterns","title":"Mixing basic drum patterns","text":"","category":"section"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"note: Note\nThis page is also available as a YouTube video here: https://youtu.be/Oog_aunpVms","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"Let's say that we have some basic drum patterns that we want to be able to combine freely at random combinations. For example,","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"(Image: Basic drum patterns)","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"where the note E means right hand, while A means left hand. These patterns can be easily combined to fill a bar, like for example 5b -> 5b -> 3 -> 3 or 5a -> 4 -> 4 -> 3, etc. They can also be combined to fill two bars and so on. Notice that some sequences, like e.g. the 5a -> 4 -> 4 -> 3, result in alternating hands: each time the sequence is played the hand that \"leads\" is swapped. This will be important later on.","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"The goal is to be able to play arbitrary sequences of them for arbitrary lengths. How does one practice that? We will use random_notes_sequence to create longer 8-bar sequences faster with the help of Julia.","category":"page"},{"location":"blog/drumpatterns/#Defining-the-Notes-1","page":"Ep. 1 - Mixing drum patterns","title":"Defining the Notes","text":"","category":"section"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"We first have to define the Notes instances that will correspond to those four basic patterns.","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"using MusicManipulations, MusicVisualizations\n\ntpq = 960 # ticks per quarter note\nsixt = 240 # duration of sixteenth note\nleft = name_to_pitch(\"A5\")\nright = name_to_pitch(\"E6\")","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"Reminder: Note(pitch, intensity, start, duration)","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"motif1 = [ # motif 5a\nNote(right, 100, 0, sixt),\nNote(left, 50, sixt, sixt),\nNote(right, 100, 2sixt, sixt),\nNote(left, 50, 3sixt, sixt),\nNote(left, 50, 4sixt, sixt)\n]\n\nmotif2 = [ # motif 5b\nNote(right, 100, 0, sixt),\nNote(left, 50, sixt, sixt),\nNote(left, 50, 2sixt, sixt),\nNote(right, 50, 3sixt, sixt),\nNote(right, 50, 4sixt, sixt)\n]\n\nmotif3 = [ # motif 3\nNote(right, 100, 0, sixt),\nNote(left, 50, sixt, sixt),\nNote(left, 50, 2sixt, sixt),\n]\n\nmotif4 = [ # motif 4\nNote(right, 100, 0, sixt),\nNote(left, 50, sixt, sixt),\nNote(right, 50, 2sixt, sixt),\nNote(right, 50, 3sixt, sixt),\n]\n\nmotifs = Notes.([motif1, motif2, motif3, motif4], tpq)","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"Now motifs stands for a pool of note sequences we can draw random samples from. Let's generate sequences that are 8-bars long (i.e. 32 quarter notes)","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"q = tpq*32\n\nnotes, seq = random_notes_sequence(motifs, q)\nnotes","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"and now we can write these to a MIDI file simply by doing writeMIDIFile(\"drums_patterns.mid\", notes) if we want to. We can also use MuseScore, to visualize and print the result. The function musescore provides this interface.","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"musescore(\"drums_patterns.png\", notes)","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"(Image: 32-bar pattern sequence)","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"this is a pre-made figure - your random sequence will probably differ","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"This worked nicely, but there is a problem: The sequence does not respect the fact that some specific patterns (5b and 4) swap the leading hand. This is what we tackle in the next section.","category":"page"},{"location":"blog/drumpatterns/#Adding-alternating-hands-and-Lyrics-1","page":"Ep. 1 - Mixing drum patterns","title":"Adding alternating hands and Lyrics","text":"","category":"section"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"Notice that random_note_sequence also returns the indices of the motifs that were used to create the sequence:","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"seq","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"We can use this information to put the correct \"stickings\". To alternate hands we simply need to replace the necessary E notes with A and vice versa. Let's define some \"meta-data\" like structures","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"accent1 = (\"5a\", false)\naccent2 = (\"5b\", true)\naccent3 = (\"3\", false)\naccent4 = (\"4\", true)\naccents = [accent1, accent2, accent3, accent4]","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"The first entry of each tuple is simply the name of the pattern which we will also show in our music score as \"lyrics\". The second entry of the tuple simply denotes whether the pattern swaps the leading hand.","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"The function that will \"inverse\" a note sticking is:","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"inverse!(n::Note) = (n.pitch = (n.pitch == left ? right : left));\nnothing #hide","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"The function that will \"count\" how long is each pattern, so that we put the lyrics on the correct positions in the score, will be:","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"note_length(s::String) = parse(Int, s[1]);\nnothing #hide","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"(remember: sixt is the duration of one sixteenth note). We now initialize an empty MIDITrack and add all events to it!","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"track = MIDITrack()\nℓ = 0\nright_leads = true\n\nfor i in 1:length(seq)\n\n    s = accents[seq[i]][1]\n    le = textevent(:lyric, s)\n    addevent!(track, ℓ*sixt, le)\n\n    if !right_leads # Invert notes\n        for j in ℓ+1:ℓ+note_length(s)\n            inverse!(notes[j])\n        end\n    end\n\n    global ℓ += note_length(s)\n\n    change = accents[seq[i]][2]\n    global right_leads = xor(right_leads, change)\nend\n\naddnotes!(track, notes)\nnotes","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"Finally, to visualize, we use musescore again, using a midi file as an input","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"musescore(\"drums_patterns_with_names.png\", MIDIFile(1, 960, [track]))","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"(Image: Correct 32-bar pattern sequence)","category":"page"},{"location":"blog/drumpatterns/#","page":"Ep. 1 - Mixing drum patterns","title":"Ep. 1 - Mixing drum patterns","text":"Isn't it cool that even the lyrics text was displayed so seamlessly?","category":"page"},{"location":"motif/musicexample/#Music-motifs-1","page":"Music motifs","title":"Music motifs","text":"","category":"section"},{"location":"motif/musicexample/#","page":"Music motifs","title":"Music motifs","text":"MotifSequenceGenerator can be applied directly to music-related setting, via Notes, with the function random_notes_sequence. In the Mixing basic drum patterns, this function (and others from JuliaMusic) are taken advantage of in real-life scenarios.","category":"page"},{"location":"motif/musicexample/#","page":"Music motifs","title":"Music motifs","text":"random_notes_sequence","category":"page"},{"location":"motif/musicexample/#MusicManipulations.random_notes_sequence","page":"Music motifs","title":"MusicManipulations.random_notes_sequence","text":"random_notes_sequence(motifs::Vector{Notes{N}}, q, δq = 0; weights)\n\nCreate a random sequence from a pool of notes (motifs) such that it has total length ℓ exactly q - δq ≤ ℓ ≤ q + δq. Notice that q is measured in ticks. Optionally pass keyword weights to sample different motifs with different weights (either as frequencies or as probabilities).\n\nReturn the result as a single Notes container, and also return the sequence of motifs used.\n\nThis function uses random_sequence from the module MotifSequenceGenerator, adapted to the Notes struct.\n\n\n\n\n\n","category":"function"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"EditURL = \"https://github.com/JuliaMusic/JuliaMusic_documentation.jl/blob/master/docs/src/blog/gaddisms.jl\"","category":"page"},{"location":"blog/gaddisms/#nd-note-Gaddisms-1","page":"Ep. 3 - Gaddisms","title":"32nd note Gaddisms","text":"","category":"section"},{"location":"blog/gaddisms/#Introduction-1","page":"Ep. 3 - Gaddisms","title":"Introduction","text":"","category":"section"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Steve Gadd is famous for being one of the first people to popularize playing fast 32nd notes between the hihat, snare and bass drum, typically using a combination of rudiments, like inverted doubles and paradiddles. Some people refer to these as \"Flutter Licks\", but I will be using the name \"Gaddisms\" here.","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"I was originally introduced to this from a YouTube video by Jungleritter, but many other drum educators have approached this, for example Austin Burcham. To get an idea you can watch the following Steve Gadd performances:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"The most basic version of these Gaddisms is definitely the following:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"In this tutorial I'll be going through the process I followed, in order to create exercises that allow me to study these Gaddisms, without having to write any combination I come with one by one, and also allowing me to easily add more or print less of them into a score.","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"The final output of this tutorial will be something like this:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"and something like this:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#Creating-the-Gaddisms-with-Julia-code-1","page":"Ep. 3 - Gaddisms","title":"Creating the Gaddisms with Julia code","text":"","category":"section"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Let's first load some basic packages and define some handy commands","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"using MusicManipulations # tools for handling MIDI data\nusing MusicVisualizations # to be able to access MuseScore\nchannel = 9 # this is the dedicated drum channel for MuseScore\nmdk = musescore_drumkey # for typing less","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"and then configure the subdivision of our notes","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"tpq = 960          # Duration of a quarter note in ticks\nsubdiv = tpq÷8     # note subdivision duration (32nd notes)\npatlen = 8*subdiv  # pattern length","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Then we define the types of notes that will be part of the 32nd note patterns we will create:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"A = Note(mdk[\"Acoustic Snare\"], 100, 0, subdiv, channel)\nR = Note(mdk[\"Closed Hi-Hat\"], 70, 0, subdiv, channel)\nL = Note(mdk[\"Side Stick\"], 70, 0, subdiv, channel)\nK = Note(mdk[\"Low Floor Tom\"], 90, 0, subdiv, channel)","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"I've made the \"kick\" note K to be a floor tom simply because MuseScore writes bass drum notes on a different voice than the rest of the notes, which makes the final score hard to read. You could use the \"real\" bass drum note by using mdk[\"Acoustic Bass Drum\"] instead.","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"In any case, the goal is to combine these four notes to make \"Gaddisms\", keeping in mind the following simple rules (to stay as close to the original Steve Gadd style as possible):","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Each Gaddism has 16 32nd notes (2 quarter notes)\nThe first half starts with a kick K and cannot end with a right hand\nThe second class starts with a right hand accent A\nR, L, K can be repeated up to two times sequentially","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"For example, the most \"standard\" pattern is KLLRRLLK ALLRRLLK: (Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"As we have defined the notes A, ... K, the simplest way to do make this pattern from notes programmatically is to combine them into a vector, e.g.","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"[K, L, L, R, R, L, L, K]","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"The problem unfortunately is that all of these notes start at the same time, so if we made them into a score, you'd have 8 32nd notes all in the first 32nd note of the bar...","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"To be able to transform this vector of notes into notes that start sequentially we define the following function:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"\"\"\"\nCombine the given notes into a notes that start sequentially.\n\"\"\"\nfunction make_pattern(v::Vector{<:AbstractNote})\n    n = Notes([v[1]], 960)\n    for i in 2:length(v)\n        push!(n, translate(v[i], (i-1)*subdiv))\n    end\n    return n\nend\n\np1 = make_pattern([K, L, L, R, R, L, L, K])\np2 = make_pattern([A, L, L, R, R, L, L, K])","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"And we can easily combine them and put them into MuseScore and see the output:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"x = combine([p1, translate(p2, patlen)])","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"musescore(\"standard.png\", x)","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Notice the use of the translate function, which ensures that the second part p2 doesn't start at the same time as p1.","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Alright, now it is only a matter of just writing down all \"Gaddisms\" that we would like to practice:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"first_half = make_pattern.([\n    [K, L, L, R, R, L, L, K],\n    [K, L, L, K, R, L, L, K],\n    [K, R, L, K, R, L, L, K],\n    [K, R, L, K, R, L, K, L],\n    [K, L, R, R, L, L, R, L],\n    [K, L, R, R, L, R, R, L],\n    [K, L, L, R, R, L, K, K],\n    [K, R, L, R, R, L, L, K],\n    [K, L, L, R, K, L, K, L],\n    [K, L, R, R, L, R, L, L],\n    [K, L, L, K, A, L, L, K],\n])\n\nsecond_half = make_pattern.([\n    [A, L, L, R, R, L, L, K],\n    [A, L, L, K, R, L, L, K],\n    [A, L, K, L, R, L, L, K],\n    [A, L, L, R, K, R, L, L],\n    [A, L, R, R, L, R, L, L],\n    [A, L, R, R, L, R, R, L],\n    [A, L, L, R, R, K, L, L],\n    [A, L, K, R, L, K, R, L],\n    [A, L, R, L, L, R, L, L],\n    [A, L, R, L, L, R, L, K],\n    [A, K, R, L, K, R, L, K],\n    [A, K, R, L, L, R, R, K],\n    [A, L, A, L, L, R, L, K],\n])\n\nsecond_half[3]","category":"page"},{"location":"blog/gaddisms/#Combining-Gaddisms-into-a-sequence-1","page":"Ep. 3 - Gaddisms","title":"Combining Gaddisms into a sequence","text":"","category":"section"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"By now every component we need is ready, and we could use any arbitrary Gaddisms to make a sequence, for example","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"x = combine([first_half[5], translate(second_half[8], patlen)])","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"musescore(\"another.png\", x)","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"The recipe is simple enough and we define a function that will just produce a sequence of arbitrary many gaddisms","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"function random_gaddisms(n = 1)\n    @assert n ≤ min(length(first_half), length(second_half))\n    r1, r2 = randperm(length(first_half)), randperm(length(second_half))\n    final = Vector{Notes}()\n    c = 0\n    for i in 1:n\n        push!(final, translate(first_half[r1[i]],  c*patlen))\n        push!(final, translate(second_half[r2[i]], (c+1)*patlen))\n        c += 8 # this adds a bar of rest, for better layouting\n    end\n    return combine(final)\nend","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"musescore(\"random1.png\", random_gaddisms(4))","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"musescore(\"random2.png\", random_gaddisms(8))","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"One can run this command arbitrary times to make arbitrary amount of random combinations, e.g. [musescore(\"randgadd_$i.pdf\", random_gaddisms(8)) for i in 1:4].","category":"page"},{"location":"blog/gaddisms/#Gaddism-Matrix-1","page":"Ep. 3 - Gaddisms","title":"Gaddism Matrix","text":"","category":"section"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"If you print and try to study many of these comdinations, as e.g. shown in the last section of this page, you will quickly realize that there must be some more efficient ways to present all this information. Well, the answer is a matrix! A matrix looks like this:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"How do you make such a matrix? with the following function:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"using PyPlot\n\nfunction gaddism_matrix(first, second; dx = 2.6, dy = 1.2) # inches per pattern\n    patternimg(path) = matplotlib.image.imread(path)[:, 640:2880, :]\n    Lf, Ls = length.((first, second))\n    fig, axs = subplots(Lf+1, Ls+1, figsize = ((Ls+1)*dx, (Lf+1)*dy))\n\n    for (fi, f) in enumerate(first)\n        musescore(\"f$(f).png\", first_half[f], display = false)\n        fimg = patternimg(\"f$(f)-1.png\")\n        axs[fi+1, 1].imshow(fimg)\n        rm(\"f$(f)-1.png\")\n        for y in ((1 - fi/(Lf+1)), (1 - (fi+1)/(Lf+1)))\n            line = matplotlib.lines.Line2D([0, 1], [y, y], color=\"k\", transform=fig.transFigure)\n            fig.add_artist(line)\n        end\n    end\n    for (si, s) in enumerate(second)\n        musescore(\"s$(s).png\", second_half[s], display = false)\n        simg = patternimg(\"s$(s)-1.png\")\n        axs[1, si+1].imshow(simg)\n        rm(\"s$(s)-1.png\")\n        for x in (si/(Ls+1), (si+1)/(Ls+1))\n            line = matplotlib.lines.Line2D([x, x], [0, 1], color=\"k\", transform=fig.transFigure)\n            fig.add_artist(line)\n        end\n    end\n    axs[1,1].text(0.5,0.5, \"Gaddism Matrix\\n(flutter licks)\\n\"*\n                  \"by George Datseris\\nusing JuliaMusic\", va=\"center\", ha=\"center\", size=12)\n    for ax in axs; ax.axis(\"off\"); end\n    fig.tight_layout()\n    fig.savefig(\"gaddmatrix_$(join(first))x$(join(second)).png\", dpi = 1200)\nend","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"This function is given two vectors of integer indices, each denoting which patterns from the first and second half to include into the matrix:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"gaddism_matrix([1, 2, 4, 5, 7], [1, 8, 5])","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"For example, the standard pattern shown in the introduction was made with this code:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"gaddism_matrix(1:4, 1:3)","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"I won't go too deep into details about gaddism_matrix, because most of the code is plotting. In essence what the function does is saves each pattern by itself via MuseScore, then loads the image as numeric data (see patternimg) and plots this image using PyPlot. The rest of the code is just layouting and adding straight lines.","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"This function is awesome because it is scalable to arbitrary amounts of first and second half patterns! For example:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"gaddism_matrix([6, 8], 1:6)","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"(Image: )","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"The way I studied this is creating 3x3 matrices and really focusing on learning the individual patterns to the point I could arbitrarily combine most of them.","category":"page"},{"location":"blog/gaddisms/#Putting-all-possible-Gaddism-combinations-into-a-PDF-1","page":"Ep. 3 - Gaddisms","title":"Putting all possible Gaddism combinations into a PDF","text":"","category":"section"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Putting all possible Gaddism combinations into a PDF is straightforward with the following simple function:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"function allgaddisms(first_half, second_half)\n    final = Vector{Notes}()\n    c = 0\n    for i in 1:length(first_half)\n        for j in 1:length(second_half)\n            push!(final, translate(first_half[i], c*patlen))\n            push!(final, translate(second_half[j], (c+1)*patlen))\n            c += 8\n        end\n    end\n    return combine(final)\nend","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"musescore(\"all.pdf\", allgaddisms(first_half, second_half));","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"Notice that this will make a huge pdf file. You can of course do:","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"musescore(\"all_from_1.pdf\", allgaddisms([first_half[1]], second_half));","category":"page"},{"location":"blog/gaddisms/#","page":"Ep. 3 - Gaddisms","title":"Ep. 3 - Gaddisms","text":"to only combine the first combination with all the others.","category":"page"},{"location":"midi/io/#Basic-MIDI-structures-1","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"","category":"section"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"MIDI files are loaded to/from disc and transformed into a Julia structure MIDIFile, which contains MIDITracks.","category":"page"},{"location":"midi/io/#MIDIFile-1","page":"Basic MIDI structures","title":"MIDIFile","text":"","category":"section"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"To read and write a MIDI file, use","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"readMIDIFile\nwriteMIDIFile","category":"page"},{"location":"midi/io/#MIDI.readMIDIFile","page":"Basic MIDI structures","title":"MIDI.readMIDIFile","text":"readMIDIFile(filename::AbstractString)\n\nRead a file into a MIDIFile data type.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.writeMIDIFile","page":"Basic MIDI structures","title":"MIDI.writeMIDIFile","text":"writeMIDIFile(filename::AbstractString, data::MIDIFile)\n\nWrite a MIDIFile as a \".mid\" file to the given filename.\n\nwriteMIDIFile(filename::AbstractString, notes::Notes)\n\nCreate a MIDIFile directly from notes, using format 1.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"The above functions return / use the MIDIFile type:","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"MIDIFile","category":"page"},{"location":"midi/io/#MIDI.MIDIFile","page":"Basic MIDI structures","title":"MIDI.MIDIFile","text":"MIDIFile <: Any\n\nType representing a file of MIDI data.\n\nFields\n\nformat::UInt16 : The format of the file. Can be 0, 1 or 2.\ntpq::Int16 : The time division of the track, ticks-per-quarter-note.\ntracks::Array{MIDITrack, 1} : The array of contained tracks.\n\n\n\n\n\n","category":"type"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"","category":"page"},{"location":"midi/io/#MIDITrack-1","page":"Basic MIDI structures","title":"MIDITrack","text":"","category":"section"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"The most important field of a MIDIFile is the tracks field. It contains as many tracks as the user wants. The tracks themselves contain all \"musical\" information in the form of the \"events\" we mentioned in MIDI: The least you need to know.","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"MIDITrack\nTrackEvent","category":"page"},{"location":"midi/io/#MIDI.MIDITrack","page":"Basic MIDI structures","title":"MIDI.MIDITrack","text":"MIDITrack <: Any\n\nMIDITrack is simply a container for TrackEvents, since its only field is events::Vector{TrackEvent}.\n\nTrack chunks begin with four bytes spelling out \"MTrk\", followed by the length (in bytes) of the track (see readvariablelength), followed by a sequence of events.\n\n\n\n\n\n","category":"type"},{"location":"midi/io/#MIDI.TrackEvent","page":"Basic MIDI structures","title":"MIDI.TrackEvent","text":"TrackEvent <: Any\n\nAbstract supertype for all MIDI events.\n\nAll track events begin with a variable length time value (see readvariablelength) and have a field named dT which contains it. This number notes after how many ticks since the last event does the current even takes place.\n\nMIDIEvents then resume with a MIDI channel message defined in constants.jl. They're followed by 1 or 2 bytes, depending on the channel message (see MIDI.EVENTTYPETOLENGTH). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.\n\nMetaEvents and SysexEvents both resume with a specific byte (see constants.jl).\n\n\n\n\n\n","category":"type"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"The TrackEvent themselves can be one of three types:","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"struct MIDIEvent <: TrackEvent\n    dT::Int\n    status::UInt8\n    data::Array{UInt8,1}\nend\n\nstruct MetaEvent <: TrackEvent\n    dT::Int\n    metatype::UInt8\n    data::Array{UInt8,1}\nend\n\nstruct SysexEvent <: TrackEvent\n    dT::Int\n    data::Array{UInt8,1}\nend","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"Typically the most relevant information of a MIDITrack are the notes contained within. For this reason, special functions getnotes and addnotes! exist, which can be found in the Notes page.","category":"page"},{"location":"midi/io/#Utility-functions-1","page":"Basic MIDI structures","title":"Utility functions","text":"","category":"section"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"BPM\nms_per_tick\naddevent!\naddevents!\ntrackname\naddtrackname!\ntextevent\nfindtextevents","category":"page"},{"location":"midi/io/#MIDI.BPM","page":"Basic MIDI structures","title":"MIDI.BPM","text":"BPM(midi)\n\nReturn the BPM where the given MIDIFile was exported at.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.ms_per_tick","page":"Basic MIDI structures","title":"MIDI.ms_per_tick","text":"ms_per_tick(tpq, bpm)\nms_per_tick(midi::MIDIFile)\n\nReturn how many miliseconds is one tick, based on the beats per minute bpm and ticks per quarter note tpq.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.addevent!","page":"Basic MIDI structures","title":"MIDI.addevent!","text":"addevent!(track::MIDITrack, time::Int, event::TrackEvent)\n\nAdd an event to the track at given time. The time is in absolute time, not relative.\n\nIf you want to add multiple events in one go, you should use the addevents! function instead.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.addevents!","page":"Basic MIDI structures","title":"MIDI.addevents!","text":"addevents!(track::MIDITrack, times, events)\n\nAdd given events to given track at given times, internally doing all translations from absolute time to relative time.\n\nUsing this function is more efficient than a loop over single addevent! calls.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.trackname","page":"Basic MIDI structures","title":"MIDI.trackname","text":"trackname(track::MIDI.MIDITrack)\n\nReturn the name of the given track as a string, by finding the \"track name\" MetaEvent.\n\nIf no such event exists, \"No track name found\" is returned.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.addtrackname!","page":"Basic MIDI structures","title":"MIDI.addtrackname!","text":"addtrackname!(track::MIDI.MIDITrack, name::String)\n\nAdd a name to the given track by attaching the \"track name\" MetaEvent to the start of the track.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.textevent","page":"Basic MIDI structures","title":"MIDI.textevent","text":"textevent(eventtype, text)\n\nCreate an event using the string text. The eventtype can be :text, :lyric, :marker, which will create the appropriate type of MetaEvent.\n\nThe returned event can be added to a MIDITrack via either addevent! or addevents! for multiple events.\n\nNotice - Cubase can read the marker events and MuseScore can read the lyrics events. We haven't seen any editor that can read the text events, so far.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#MIDI.findtextevents","page":"Basic MIDI structures","title":"MIDI.findtextevents","text":"findtextevents(eventtype, track)\n\nFind all \"text\" events specifield by eventtype in the track. The eventtype can be :text, :lyric, :marker, which will find the appropriate MetaEvents.\n\nFor convenience, this function does not return the events themselves. Instead, it returns three vectors: the first is the strings of the events, the second is the indices of the events in the track and the third is the absolute position of the events (since start of track).\n\nNotice - common music score editors like e.g. MuseScore, GuitarPro, etc., do not export the lyrics and text information when exporting midi files.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#Low-Level-API-1","page":"Basic MIDI structures","title":"Low-Level API","text":"","category":"section"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"In this section we show the low-level API that allows one to actually read bytes from a file and transform them into Julia structures.","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"readvariablelength","category":"page"},{"location":"midi/io/#MIDI.readvariablelength","page":"Basic MIDI structures","title":"MIDI.readvariablelength","text":"readvariablelength(f::IO)\n\nVariable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we're looking at the last byte in the sequence. The remaining 7 bits indicate the number.\n\n\n\n\n\n","category":"function"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"Other useful functions that are not exported are","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"writeevent\nreadMIDIevent\nreadmetaevent\nreadsysexevent\nget_abs_pos","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"Lastly, see the file MIDI/src/constants.jl for message types, event types, etc.","category":"page"},{"location":"midi/io/#MIDI:-The-least-you-need-to-know-1","page":"Basic MIDI structures","title":"MIDI: The least you need to know","text":"","category":"section"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"This section serves as a crash-course on the MIDI format. For more info see the wikipedia page, read the official MIDI specifications or have a look at the comprehensive tutorial at recordingblogs.com.","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"A MIDI file typically comes in pieces called tracks that play simultaneously. Each track can have 16 different channels, numbered 0-15. Each channel can be thought of as a single instrument, though that instrument can be changed throughout that track. A track contains events. The three types of events are MIDI events, META events, and system exclusive (SYSEX) events. All events begin with the time since the last event (dT) in ticks. The number of ticks per quarter note is given by the tpq of the midi file, MIDIFile.tpq (see MIDIFile).","category":"page"},{"location":"midi/io/#","page":"Basic MIDI structures","title":"Basic MIDI structures","text":"MIDI events handle things related to the actual notes as well as sound texture, such as playing a note or moving the pitch-wheel.\nMETA events take care of things like adding copyright text, authorship information, track naming etc.\nSYSEX events are used to transmit arbitrary data. Their contents depend on the intended recipient.","category":"page"},{"location":"printplot/noteplotter/#Plotting-Notes-1","page":"Plotting notes","title":"Plotting Notes","text":"","category":"section"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"With MusicVisualizations it is possible to plot Notes similarly to a \"piano roll\" that DAW like Cubase use. This is achieved with the noteplotter function, which uses PyPlot.","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"noteplotter","category":"page"},{"location":"printplot/noteplotter/#MusicVisualizations.noteplotter","page":"Plotting notes","title":"MusicVisualizations.noteplotter","text":"noteplotter(notes::Notes; kwargs...)\n\nPlot the given notes on a \"piano roll\" like setting with\n\nx axis being the position of the notes\ny axis being the \"pitch\" or \"value\" of the notes (see below)\ncolor being the velocity of the notes\n\nThen return the values of the y axis.\n\nKeywords\n\nst = (notes[1].position ÷ notes.tpq) * notes.tpq  time to start plotting from\nfi = st + 16notes.tpq time to stop plotting at, by default 16 quarter notes, i.e. four bars. Give Inf if you want to plot until the end of the notes.\nax = (PyPlot.figure(); PyPlot.gca()) the axis to plot on.\ncmap = \"viridis\" the colormap to use for the velocity.\ngrid = 0:0.25:1 a grid to plot along with the notes (by default the 16th notes). Give nothing if you don't want grid lines to be plotted.\nnames : a dictionary that given the y-axis value returns how this value should be named. By default the function pitch_to_name is used, along with a heuristic to only name around 7 notes.\nplotnote! A function with call arguments plotnote!(ax, note, cmap) (with cmap a colormap instance, not a string), that actually plots the notes. By default plots a \"piano-roll\".\n\nThe plotnote! argument allows for customization. The function is supposed to plot a note on the given axis and return the \"value\" of the note. See the official documentation for an example of how this is taken advantage of to e.g. plot drum notes.\n\n\n\n\n\n","category":"function"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"","category":"page"},{"location":"printplot/noteplotter/#Piano-notes-1","page":"Plotting notes","title":"Piano notes","text":"","category":"section"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"using MusicVisualizations, PyPlot\n# MusicVisualizations reexports MusicManipulations for convenience\n\n# load a band performance (with metronome)\nmidi = readMIDIFile(joinpath(@__DIR__, \"mfi_grapevine_1.mid\"))\n\ngrid = 0:1//4:1\npiano = getnotes(midi, 4)","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"noteplotter(piano; st = 15300, grid = grid)\ntight_layout() # hide\nsavefig(\"pianoroll.png\"); nothing # hide","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"(Image: )","category":"page"},{"location":"printplot/noteplotter/#Drum-notes-1","page":"Plotting notes","title":"Drum notes","text":"","category":"section"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"The nice thing about noteplotter is that it is fully customizable, via its argument plotnote!. In this section we show an example of how noteplotter can be used to plot drum notes in drum notation, similarly to Cubase's GM Map.","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"The first step is defining a specific function for plotnote!. Since the duration of the notes does not have meaning in this case, we can just scatter plot their position. Also, we can use different symbols for different drum parts, e.g. circles for snare and bass drum and Xs for hihat and cymbals.","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"function plotdrumnote!(ax, note, cmap)\n    p = note.pitch\n    if p == 0x24 # kick\n        v, m = 1, \"o\"\n    elseif p ∈ (0x26, 0x28) # snare\n        v, m = 3, \"o\"\n    elseif p ∈ (0x16, 0x1a) # hihat rim\n        v, m = 5, \"X\"\n    elseif p ∈ (0x2e, 0x2a) # hihat head\n        v, m = 5, \"x\"\n    elseif p == 0x35 # ride bell\n        v, m = 6, \"D\"\n    elseif p == 0x33 # ride head\n        v, m = 6, \"x\"\n    elseif p == 0x3b # ride rim\n        v, m = 6, \"X\"\n    elseif p ∈ (0x30, 0x32) # tom 1\n        v, m = 4, \"s\"\n    elseif p ∈ (0x2b, 0x3a) # tom 3\n        v, m = 2, \"s\"\n    elseif p ∈ (0x31, 0x37, 0x34, 0x39)\n        v, m = 7, \"X\"\n    elseif p == 0x2c # hihat foot\n        v, m = 1, \"x\"\n    else\n        error(\"Unknown pitch $(UInt8(p))\")\n    end\n    ax.scatter(note.position, v, marker = m, s = 250,\n        color = cmap(min(note.velocity, 127)/127))\n    return v\nend","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"(notice that the above function is hand-tailored for a specific e-drumset)","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"To make things even prettier, one can also use custom names for the notes:","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"TD50_PLOT = Dict(\n    1 => \"kick\",\n    3 => \"snare\",\n    5 => \"hihat\",\n    6 => \"ride\",\n    4 => \"tom1\",\n    2 => \"tom3\",\n    7 => \"crash\",\n)","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"And now here is how plotting some drum notes looks like:","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"drums = getnotes(midi, 3)\ndrums = translate(drums, -300) # constant delay\n\nnoteplotter(drums; st = 15300, grid = grid,\n                   names=TD50_PLOT, plotnote! = plotdrumnote!)\ntight_layout() # hide\nsavefig(\"drumroll.png\"); nothing # hide","category":"page"},{"location":"printplot/noteplotter/#","page":"Plotting notes","title":"Plotting notes","text":"(Image: )","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"EditURL = \"https://github.com/JuliaMusic/JuliaMusic_documentation.jl/blob/master/docs/src/blog/garibaldi_dragadiddle.jl\"","category":"page"},{"location":"blog/garibaldi_dragadiddle/#Garibaldi's-FootHand-doubles-1","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Garibaldi's Foot+Hand doubles","text":"","category":"section"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Have a look at the following simple rudiment involving a double stroke","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"(Image: dragadiddle)","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Here the sticking could be single strokes, as in Rr L R L on repeat, or it can also follow the standard \"dragadiddle\", Rr L R R Ll R L L.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"David Garibaldi uses and teaches an interesting concept that replaces the double stroke by a foot+hand combination. This works irrespectively of the above stickings, and the double stroke bomes a foot stroke and a tom stroke. It looks like this:","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"(Image: dragadiddle_garibalid)","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"I wished to study this concept in detail, and in the following I set up some code that produces exercises for me to work on. It also uses a relatively new feature of random_notes_sequence which can weight different patterns with different probabilities, so that they appear more or less frequently.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#Textbook-exercises-1","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Textbook exercises","text":"","category":"section"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Before we devle into the actual random sequences of this new kind of pattern I create some straight forward exercises that have this pattern in different locations in the bar. For the sticking, I assume the single strokes, so that I also have exercise variants with two foot-hand strokes next to each other.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"First, let's define the basic variables necessary for the code.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"using MusicVisualizations # re-exports MusicManipulations\n\nbass = musescore_drumkey[\"Acoustic Bass Drum\"] # for readability\nsnare = musescore_drumkey[\"Acoustic Snare\"]\ntom = musescore_drumkey[\"Low-Mid Tom\"]\nmidichannel = 9\ntpq = 960\nsixt = 960 ÷ 4","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"For creating the patterns, one should notice that only two different \"motifs\" are necessary, one with the foot+hand double stroke and one that is only a single stroke. We can then use clever programming to create all possible combinations.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"motif0 = [\nNote(snare, 100, 0, sixt, midichannel),\n]\n\nmotif1 = [\nNote(bass, 100, 0, sixt÷2, midichannel),\nNote(tom, 100, sixt÷2, sixt÷2, midichannel),\n]","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"The first step is to create some basic exercises that put this double foot+hand stroke into the different possible locations within a quarter note. These variations are 4 in total. In the following we will store them all into a single exercises container, while each exercise will be bars bars long.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"bars = 2\nexercises = Note[]\n\nfor j in 1:4 # create the 4 possible variations\n\n    # Create 1 quarter note of the variations\n    exercise = [translate(motif0, k*sixt) for k in 0:3]\n    exercise[j] = translate(motif1, (j-1)*sixt)\n    exercise = vcat(exercise...)\n    ex0 = copy(exercise)\n\n    # Repeat to fill one bar with variation. 1 quarter note = 4sixt\n    for k in 1:3; append!(exercise, translate(ex0, 4k*sixt)); end\n    ex0 = copy(exercise)\n\n    # Repeat as many bars as needed. 1 bar = 16 sixt\n    for b in 0:bars-1; append!(exercise, translate(ex0, 16b*sixt)); end\n\n    # Add it to the exercises (but translated for the bars)\n    append!(exercises, translate(exercise, (j-1)*bars*16*sixt))\nend","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"We then create a second exrcise type where one quarter note will contain two doubles of foot+hand. There are two ways for this (assuming that we do not want the doubles to be next to each other).","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"for j in 5:6\n    exercise = [translate(motif0, k*sixt) for k in 0:7] # repeat it 8 times\n    for m in (j, j+2)\n        exercise[m] = translate(motif1, (m-1)*sixt)\n    end\n    exercise = vcat(exercise...)\n    ex0 = copy(exercise)\n\n    # Repeat to fill one bar with variation. 1 quarter note = 4sixt\n    # Notice this is a 2 quarter not pattern\n    for k in 1:1; append!(exercise, translate(ex0, 8k*sixt)); end\n    ex0 = copy(exercise)\n\n    # Repeat as many bars as needed. 1 bar = 16 sixt\n    for b in 0:bars-1; append!(exercise, translate(ex0, 16b*sixt)); end\n\n    # Add it to the exercises (but translated for the bars)\n    append!(exercises, translate(exercise, (j-1)*bars*16*sixt))\nend","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Finally, one last exercise with the foot+hand double repeated every three sixteen-th notes.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"motif001 = [\nNote(bass, 100, 0, sixt÷2, midichannel),\nNote(tom, 100, sixt÷2, sixt÷2, midichannel),\nNote(snare, 100, sixt, sixt, midichannel),\nNote(snare, 100, 2sixt, sixt, midichannel),\n]\n\nj = 7\nexercise = [translate(motif001, 3k*sixt) for k in 0:7] # repeat it 10 times\nexercise = vcat(exercise...)\nappend!(exercises, translate(exercise, (j-1)*bars*16*sixt))\nexercises","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Nowe we use musescore to make a sheet of the exercises","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"musescore(\"garibaldi_draga_exercise.png\", Notes(exercises, tpq))","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"(Image: exercises)","category":"page"},{"location":"blog/garibaldi_dragadiddle/#Randomized-exercises-1","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Randomized exercises","text":"","category":"section"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Now I want to have random sequences with a foot+hand double stroke springled into random locations. This is easy to do withrandom_note_sequence. However, I want to be sure that a double stroke will never be followed by another double stroke. To ensure this, I define","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"motif2 = [\nNote(bass, 100, 0, sixt÷2, midichannel),\nNote(tom, 100, sixt÷2, sixt÷2, midichannel),\nNote(snare, 100, sixt, sixt, midichannel),\n]","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Recall that motif0 is a normal single stroke. Therefore, I have to randomly mix motif0 and motif2","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"motifs = Notes.([motif0, motif2], tpq)","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"To make the exercise easy, I want the double stroke to not appear too often. This is easily done by adjusting the  weight keyword:","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"rseq, = random_notes_sequence(motifs, 16sixt*16; weights = [4, 1])\nrseq","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"And again, export it into a score:","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"musescore(\"garibaldi_draga_sequence_easy.png\", Notes(exercises, tpq))","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"(Image: exercises)","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"Finally, I'll make one more exercise where the foot+hand double appears a bit more frequently.","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"rseq, = random_notes_sequence(motifs, 16sixt*16; weights = [2, 1])","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"musescore(\"garibaldi_draga_sequence_hard.png\", Notes(exercises, tpq))","category":"page"},{"location":"blog/garibaldi_dragadiddle/#","page":"Ep. 2 - Garibaldi inspired dragaddidle","title":"Ep. 2 - Garibaldi inspired dragaddidle","text":"(Image: exercises)","category":"page"},{"location":"mm/extraction/#Music-data-extraction-1","page":"Music data extraction","title":"Music data extraction","text":"","category":"section"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"The functions described in this page allow for easier extraction of data from music recordings (in the form of MIDI). A highlight of JuliaMusic is the timeseries function, which allows one to directly get gridded timeseries from arbitrary Notes structures.","category":"page"},{"location":"mm/extraction/#Basic-Data-Extraction-1","page":"Music data extraction","title":"Basic Data Extraction","text":"","category":"section"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"firstnotes\nfilterpitches\nseparatepitches\ncombine\nrelpos","category":"page"},{"location":"mm/extraction/#MusicManipulations.firstnotes","page":"Music data extraction","title":"MusicManipulations.firstnotes","text":"firstnotes(notes, grid)\n\nReturn the notes that first appear in each grid point, without quantizing them.\n\nThis function does not consider the notes modulo the quarter note! Different quarter notes have different grid points.\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#MusicManipulations.filterpitches","page":"Music data extraction","title":"MusicManipulations.filterpitches","text":"filterpitches(notes::Notes, filters) -> newnotes\n\nOnly keep the notes that have a pitch specified in filters (one or many pitches).\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#MusicManipulations.separatepitches","page":"Music data extraction","title":"MusicManipulations.separatepitches","text":"separatepitches(notes::Notes [, allowed])\n\nGet a dictionary \"pitch\"=>\"notes of that pitch\". Optionally only keep pitches that are contained in allowed.\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#MusicManipulations.combine","page":"Music data extraction","title":"MusicManipulations.combine","text":"combine(note_container) -> notes\n\nCombine the given container (either Array{Notes} or Dict{Any, Notes}) into a single Notes instance. In the process, sort the notes by position in the final container.\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#MusicManipulations.relpos","page":"Music data extraction","title":"MusicManipulations.relpos","text":"relpos(notes::Notes, grid)\n\nReturn the relative positions of the notes with respect to the current grid, i.e. all notes are brought within one quarter note.\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#Advanced-Data-Extraction-1","page":"Music data extraction","title":"Advanced Data Extraction","text":"","category":"section"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"estimate_delay\nestimate_delay_recursive","category":"page"},{"location":"mm/extraction/#MusicManipulations.estimate_delay","page":"Music data extraction","title":"MusicManipulations.estimate_delay","text":"estimate_delay(notes, grid)\n\nEstimate the average temporal deviation of the given notes from the quarter note grid point. The notes are classified according to the grid and only notes in the first and last grid bins are used. Their position is subtracted from the nearby quarter note and the returned value is the average of this operation.\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#MusicManipulations.estimate_delay_recursive","page":"Music data extraction","title":"MusicManipulations.estimate_delay_recursive","text":"estimate_delay_recursive(notes, grid, m)\n\nDo the same as estimate_delay but for m times, while in each step shifting the notes by the previously found delay. This improves the accuracy of the algorithm, because the distribution of the quarter notes is estimated better and better each time. The function should typically converge after a couple of m.\n\nThe returned result is the estimated delay, in integer (ticks), as only integers can be used to actually shift the notes around.\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#Timeseries-1","page":"Music data extraction","title":"Timeseries","text":"","category":"section"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"timeseries","category":"page"},{"location":"mm/extraction/#MusicManipulations.timeseries","page":"Music data extraction","title":"MusicManipulations.timeseries","text":"timeseries(notes::Notes, property::Symbol, f, grid; segmented = false) -> tvec, ts\n\nProduce a timeseries of the property of the given notes, by first quantizing on the given grid (to avoid actual quantization use the grid 0:1//notes.tpq:1). Return the time vector tvec in ticks and the produced timeseries ts.\n\nAfter quantization, it is often the case that many notes are in the same bin of the grid. The function f denotes which value of the vector of the property of the notes to keep. Typical values are minimum, maximum, mean, etc. Notice that bins without any note in them obtain the value missing, regardless of the function f or the property.\n\nIf the property is :velocity, :pitch, or :duration the function behaves exactly as described. The property can also be :position. In this case, the timeseries ts contain the timing deviations of the notes with respect to the tvec vector (these numbers are known as microtiming deviations in the literature).\n\nIf 'segmented = true', the notes are segmented according to the grid in order to respect the information of their duration, see segment. Otherwise the notes are treated as point events with no duration (it makes no sense to choose :duration with segmented).\n\n\n\n\n\ntimeseries(notes::Notes, f, grid) -> tvec, ts\n\nIf property is not given, then f should take as input a Notes instance and output a numeric value. This is useful for example in cases where one would want the timeseries of the velocities of the notes of the highest pitch.\n\n\n\n\n\n","category":"function"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"","category":"page"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"Here is an example:","category":"page"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"using MusicManipulations, PyPlot, Statistics\nmidi = readMIDIFile(testmidi())\nnotes = getnotes(midi, 4)\n\nswung_8s = [0, 2//3, 1]\nt, vel = timeseries(notes, :velocity, mean, swung_8s)\n\nnotmiss = findall(!ismissing, vel)\n\nfig, (ax1, ax2) = subplots(2,1)\nax1.scatter(t[notmiss], vel[notmiss])\nax1.set_ylabel(\"velocity\")\n\nt, mtd = timeseries(notes, :position, mean, swung_8s)\nax2.scatter(t[notmiss], mtd[notmiss], color = \"C1\")\nax2.set_ylabel(\"timing deviations\")\nax2.set_xlabel(\"ticks\")\ntight_layout() # hide\nsavefig(\"timeseries.png\"); nothing # hide","category":"page"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"(Image: )","category":"page"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"","category":"page"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"An example code that obtains the velocity of the notes with highest pitch in each bin is this one:","category":"page"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"notes = getnotes(midi, 4)\n\nfunction f(notes)\n    m, i = findmax(pitches(notes))\n    notes[i].velocity\nend\n\ngrid = 0:1//3:1\ntvec2, ts2 = timeseries(notes, f, grid)","category":"page"},{"location":"mm/extraction/#Segmentation-1","page":"Music data extraction","title":"Segmentation","text":"","category":"section"},{"location":"mm/extraction/#","page":"Music data extraction","title":"Music data extraction","text":"segment","category":"page"},{"location":"mm/extraction/#MusicManipulations.segment","page":"Music data extraction","title":"MusicManipulations.segment","text":"segment(notes, grid) → segmented_notes\n\nQuantize the positions and durations of notes and then segment them (i.e. cut them into pieces) according to the duration of a grid unit. This function only works with AbstractRange grids, i.e. equi-spaced grids like 0:1//3:1.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#Note-Tools-1","page":"Note Tools","title":"Note Tools","text":"","category":"section"},{"location":"mm/notetools/#","page":"Note Tools","title":"Note Tools","text":"This page describes functions that allow you to very conveniently work with and manipulate Note, Notes, and similar for example you can easily translate in time or transpose them in pitch.","category":"page"},{"location":"mm/notetools/#","page":"Note Tools","title":"Note Tools","text":"The functions velocities, positions, pitches, durations return the respective property when given some Notes.","category":"page"},{"location":"mm/notetools/#","page":"Note Tools","title":"Note Tools","text":"Other functions follow:","category":"page"},{"location":"mm/notetools/#","page":"Note Tools","title":"Note Tools","text":"translate\r\ntranspose\r\nlouden\r\nrepeat\r\ntimesort!","category":"page"},{"location":"mm/notetools/#MusicManipulations.translate","page":"Note Tools","title":"MusicManipulations.translate","text":"translate(notes, ticks)\n\nTranslate the notes for the given amount of ticks. Also works for a single note.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#Base.transpose","page":"Note Tools","title":"Base.transpose","text":"transpose(notes, semitones)\n\nTranspose the notes by the given amount of semitones. Also works for a single note.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#MusicManipulations.louden","page":"Note Tools","title":"MusicManipulations.louden","text":"louden(notes, v::Int)\n\nChange the velocity of the notes by v (which could also be negative). Also works for a single note.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#Base.repeat","page":"Note Tools","title":"Base.repeat","text":"repeat(notes, i = 1)\n\nRepeat the notes i times, by successively adding duplicates of notes shifted by the total duration of notes. Return a single Notes container for convenience.\n\nThe function assumes that notes are timesorted.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#MusicManipulations.timesort!","page":"Note Tools","title":"MusicManipulations.timesort!","text":"timesort!(notes::Notes)\n\nIn-place sort the notes by their temporal position. Use timesort for a non-mutating version.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#","page":"Note Tools","title":"Note Tools","text":"","category":"page"},{"location":"mm/notetools/#","page":"Note Tools","title":"Note Tools","text":"And for getting default notes:","category":"page"},{"location":"mm/notetools/#","page":"Note Tools","title":"Note Tools","text":"testmidi\r\ntestnotes\r\nrandomnotes","category":"page"},{"location":"mm/notetools/#MIDI.testmidi","page":"Note Tools","title":"MIDI.testmidi","text":"testmidi()\n\nReturn the path to a test MIDI file.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#MIDI.testnotes","page":"Note Tools","title":"MIDI.testnotes","text":"testnotes()\n\nReturn a test set of human-played MIDI notes on the piano.\n\n\n\n\n\n","category":"function"},{"location":"mm/notetools/#MusicManipulations.randomnotes","page":"Note Tools","title":"MusicManipulations.randomnotes","text":"randomnotes(n::Int, tpq = 960)\n\nGenerate some random notes that start sequentially.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This documentation describes how to use packages of the JuliaMusic, which are about reading, manipulating and saving data related with music, and are written in the Julia programming language. Most of the functionality comes in the form of the MIDI format which is described later on this page.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: Latest News\nSegmentation of notes: segment! Repetition of notes: repeat!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The current documentation was built with the following package versions","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using Pkg.API: installed\nins = installed()\nfunction f()\nfor pkg in [\"MIDI\", \"MotifSequenceGenerator\",\n            \"MusicManipulations\", \"MusicVisualizations\"]\n  println(rpad(\" * $(pkg) \", 30, \".\"), \" $(ins[pkg])\")\nend\nend","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"f() # hide","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using Literate.jl and Documenter.jl. The documentation is written and maintained by George Datseris.","category":"page"},{"location":"#Getting-Started-1","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The current documentation assumes that you are already familiar with the MIDI format and the Julia language. After you have installed Julia, you can install the packages you'd like by pressing ] in the Julia REPL (to access the package manager mode) and then add MIDI MusicManipulations. To learn a bit more about the MIDI format you can see the MIDI: The least you need to know section. The Overview section displays the offered functionality of JuliaMusic.","category":"page"},{"location":"#Citing-1","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you used MIDI.jl or MusicManipulations.jl in research that resulted in publication, then please cite our paper using the following BibTeX entry:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@article{Datseris2019,\n  doi = {10.21105/joss.01166},\n  url = {https://doi.org/10.21105/joss.01166},\n  year  = {2019},\n  month = {mar},\n  publisher = {The Open Journal},\n  volume = {4},\n  number = {35},\n  pages = {1166},\n  author = {George Datseris and Joel Hobson},\n  title = {{MIDI}.jl: Simple and intuitive handling of MIDI data.},\n  journal = {The Journal of Open Source Software}\n}","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can get an idea of the scientific projects that these software are used here: https://www.nature.com/articles/s41598-019-55981-3","category":"page"},{"location":"#Overview-1","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"#MIDI-1","page":"Introduction","title":"MIDI","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MIDI.jl is a module that defines fundamental types like tracks, reading/writing functionality, note functionality and other basic stuff.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Basic MIDI structures : The API of basic types like midi files and tracks, as well as IO. Various utility functions are included as well.\nNotes : The Note construct describes a music note. Many convenience tools are also provided in the same page, like e.g. turning a note pitch to a string like A♯3.","category":"page"},{"location":"#MusicManipulations-1","page":"Introduction","title":"MusicManipulations","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The MusicManipulations.jl package has more advanced functionality about note processing, data extraction, quantizing and other similar processes that related to music data.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Note Tools for easy handling of notes.\nQuantizing for quantizing and classifying notes on a given grid.\nMusic data extraction.","category":"page"},{"location":"#MusicVisualizations-1","page":"Introduction","title":"MusicVisualizations","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This functionality allows you to either print MIDI data into a music score using musescore, or plot notes directly like a \"piano roll\" with the customizable function noteplotter.","category":"page"},{"location":"#MotifSequenceGenerator-1","page":"Introduction","title":"MotifSequenceGenerator","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"MotifSequenceGenerator.jl is a very simple module that does a very simple thing: based on a pool of motifs with specified lengths, it makes a random sequence out of them so that the sequence also has a specified length!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Motif sequence generation introduces the module and has a basic usage example.\nMusic motifs applies this to notes.","category":"page"},{"location":"#Becoming-a-better-drummer-blog-1","page":"Introduction","title":"Becoming a better drummer blog","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This section of the documentation is more like a blog than a documentation. In these  pages I describe how I use the packages of JuliaMusic, and the programming language Julia, to help myself become a better drummer.","category":"page"},{"location":"motif/basic/#Motif-sequence-generation-1","page":"Motif sequence generator","title":"Motif sequence generation","text":"","category":"section"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"MotifSequenceGenerator\nrandom_sequence","category":"page"},{"location":"motif/basic/#MotifSequenceGenerator","page":"Motif sequence generator","title":"MotifSequenceGenerator","text":"MotifSequenceGenerator\n\nThis module generates random sequences of motifs, under the constrain that the sequence has some total length ℓ so that q - δq ≤ ℓ ≤ q + δq. All main functionality is given by the function random_sequence.\n\n\n\n\n\n","category":"module"},{"location":"motif/basic/#MotifSequenceGenerator.random_sequence","page":"Motif sequence generator","title":"MotifSequenceGenerator.random_sequence","text":"random_sequence(motifs::Vector{M}, q, limits, translate, δq = 0; kwargs...)\n\nCreate a random sequence of motifs of type M, under the constraint that the sequence has \"length\" ℓ exactly within q - δq ≤ ℓ ≤ q + δq. Return the sequence itself as well as the sequence of indices of motifs used to create it. A vector of probabilities weights can be given as a keyword argument, which then dictates the sampling probability for each entry of motifs for the initial sequence created.\n\n\"length\" here means an abstracted length defined by the struct M, based on the limits and translate functions. It does not refer to the amount of elements!\n\nM can be anything, given the two functions\n\nlimits(motif) : Some function that given the motif it returns the (start, fine) of the the motif in the same units as q. This function establishes a measure of length, which simply is fine - start.\ntranslate(motif, t) : Some function that given the motif it returns a new motif which is translated by t (either negative or positive), with respect to the same units as q.\n\nOther Keywords\n\nPlease see the source code (use @which) for a full description of the algorithm.\n\ntries = 5 : Up to how many initial random sequences are accepted.\ntaulcut = 2 : Up to how times an element is dropped from the initial guess.\nsummands = 3 : Up to how many motifs may be combined as a sum to complete a sequence.\n\n\n\n\n\n","category":"function"},{"location":"motif/basic/#Simple-Example-1","page":"Motif sequence generator","title":"Simple Example","text":"","category":"section"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"This example illustrates how the module MotifSequenceGenerator works using a simple struct. For a more realistic, and much more complex example, see the example using music notes.","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"Let's say that we want to create a random sequence of \"shouts\", which are described by the struct","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"struct Shout\n  shout::String\n  start::Int\nend","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"Let's first create a vector of shouts that will be used as the pool of possible motifs that will create the random sequence:","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"using Random\nshouts = [Shout(uppercase(randstring(rand(3:5))), rand(1:100)) for k in 1:5]","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"Notice that at the moment the values of the .start field of Shout are irrelevant. MotifSequenceGenerator will translate all motifs to start point 0 while operating.","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"Now, to create a random sequence, we need to define two concepts:","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"shoutlimits(s::Shout) = (s.start, s.start + length(s.shout) + 1);\n\nshouttranslate(s::Shout, n) = Shout(s.shout, s.start + n);","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"This means that we accept that the temporal length of a Shout is length(s.shout) + 1.","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"We can now create random sequences of shouts that have total length of exactly q:","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"using MotifSequenceGenerator\nq = 30\nsequence, idxs = random_sequence(shouts, q, shoutlimits, shouttranslate)\nsequence","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"sequence, idxs = random_sequence(shouts, q, shoutlimits, shouttranslate)\nsequence","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"Notice that it is impossible to create a sequence of length e.g. 7 with the above pool. Doing random_sequence(shouts, 7, shoutlimits, shouttranslate) would throw an error.","category":"page"},{"location":"motif/basic/#Floating-point-lengths-1","page":"Motif sequence generator","title":"Floating point lengths","text":"","category":"section"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"The lengths of the motifs do not have to be integers. When using motifs with floating lengths, it is advised to give a non-0 δq to random_sequence. The following example modifies the Shout struct and shows how it can be done with floating length.","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"struct FloatShout\n  shout::String\n  dur::Float64\n  start::Float64\nend\n\nrs(x) = uppercase(randstring(x))\n\nshouts = [FloatShout(rs(rand(3:5)), rand()+1, rand()) for k in 1:5]\nshoutlimits(s::FloatShout) = (s.start, s.start + s.dur);\nshouttranslate(s::FloatShout, n) = FloatShout(s.shout, s.dur, s.start + n);\n\nq = 10.0\nδq = 1.0\n\nr, s = random_sequence(shouts, q, shoutlimits, shouttranslate, δq)\n\nr","category":"page"},{"location":"motif/basic/#","page":"Motif sequence generator","title":"Motif sequence generator","text":"s","category":"page"}]
}
