{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nThis documentation describes how to use packages of the \nJuliaMusic\n. They are about reading, manipulating and saving data related with music. Most of the functionality comes in the form of the \nMIDI\n format which is described later on this page.\n\n\nThe current documentation was built with the following versions\n\n\n * MIDI \u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5 0.8.0\n * MotifSequenceGenerator \u22c5\u22c5\u22c5\u22c5 0.1.1\n * MusicManipulations \u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5 0.1.0\n\n\n\n\n\n\n\nOverview\n\n\n\n\nMIDI\n\n\nMIDI.jl\n is a module that defines fundamental types like tracks, reading/writing functionality, note functionality and other basic stuff.\n\n\n\n\nBasic MIDI API\n : The API of basic types like midi files and tracks, as well as IO. Various utility functions are included as well.\n\n\nNotes\n : The \nNote\n construct describes a music note. Many convenience tools are also provided in the same page, like e.g. turning a not pitch to a string like \nA\u266f3\n.\n\n\n\n\n\n\nMusicManipulations\n\n\nThe \nMusicManipulations.jl\n package has more advanced functionality about note processing, data extraction, quantizing and other similar processes that related to music data.\n\n\n\n\nConvenience tools\n.\n\n\nQuantizing \n Classifying Notes\n on a given grid.\n\n\nAdvanced Music Data Extraction\n.\n\n\nMore coming soon.\n\n\n\n\n\n\nMotifSequenceGenerator\n\n\nMotifSequenceGenerator.jl\n is a very simple module that does a very simple thing: based on a pool of motifs with specified lengths, it makes a random sequence out of them so that the sequence also has a specified length!\n\n\n\n\nMotif Sequences\n introduces the module and has a basic usage example.\n\n\nMusic Motifs Example\n shows a real-world use case where the module is used to produce music sequences.\n\n\n\n\n\n\nMIDI: The least you need to know\n\n\nThis section serves as a crash-course on the MIDI format. For more info see the \nwikipedia\n page, read the \nofficial MIDI specifications\n or have a look at the comprehensive tutorial \nat recordingblogs.com\n.\n\n\nA MIDI file typically comes in pieces called tracks that play simultaneously. Each track can have 16 different channels, numbered 0-15. Each channel can be thought of as a single instrument, though that instrument can be changed throughout that track. A track contains events. The three types of events are MIDI events, META events, and system exclusive (SYSEX) events. All events begin with the time since the last event (dT) in ticks. The number of ticks per quarter note is given by the \ntpq\n of the midi file, \nMIDIFile.tpq\n (see \nMIDIFile\n).\n\n\n\n\nMIDI events handle things related to the actual notes as well as sound texture, such as playing a note or moving the pitch-wheel.\n\n\nMETA events take care of things like adding copyright text, authorship information, track naming etc.\n\n\nSYSEX events are used to transmit arbitrary data. Their contents depend on the intended recipient.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "This documentation describes how to use packages of the  JuliaMusic . They are about reading, manipulating and saving data related with music. Most of the functionality comes in the form of the  MIDI  format which is described later on this page.  The current documentation was built with the following versions   * MIDI \u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5 0.8.0\n * MotifSequenceGenerator \u22c5\u22c5\u22c5\u22c5 0.1.1\n * MusicManipulations \u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5\u22c5 0.1.0", 
            "title": "Introduction"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#midi", 
            "text": "MIDI.jl  is a module that defines fundamental types like tracks, reading/writing functionality, note functionality and other basic stuff.   Basic MIDI API  : The API of basic types like midi files and tracks, as well as IO. Various utility functions are included as well.  Notes  : The  Note  construct describes a music note. Many convenience tools are also provided in the same page, like e.g. turning a not pitch to a string like  A\u266f3 .", 
            "title": "MIDI"
        }, 
        {
            "location": "/#musicmanipulations", 
            "text": "The  MusicManipulations.jl  package has more advanced functionality about note processing, data extraction, quantizing and other similar processes that related to music data.   Convenience tools .  Quantizing   Classifying Notes  on a given grid.  Advanced Music Data Extraction .  More coming soon.", 
            "title": "MusicManipulations"
        }, 
        {
            "location": "/#motifsequencegenerator", 
            "text": "MotifSequenceGenerator.jl  is a very simple module that does a very simple thing: based on a pool of motifs with specified lengths, it makes a random sequence out of them so that the sequence also has a specified length!   Motif Sequences  introduces the module and has a basic usage example.  Music Motifs Example  shows a real-world use case where the module is used to produce music sequences.", 
            "title": "MotifSequenceGenerator"
        }, 
        {
            "location": "/#midi-the-least-you-need-to-know", 
            "text": "This section serves as a crash-course on the MIDI format. For more info see the  wikipedia  page, read the  official MIDI specifications  or have a look at the comprehensive tutorial  at recordingblogs.com .  A MIDI file typically comes in pieces called tracks that play simultaneously. Each track can have 16 different channels, numbered 0-15. Each channel can be thought of as a single instrument, though that instrument can be changed throughout that track. A track contains events. The three types of events are MIDI events, META events, and system exclusive (SYSEX) events. All events begin with the time since the last event (dT) in ticks. The number of ticks per quarter note is given by the  tpq  of the midi file,  MIDIFile.tpq  (see  MIDIFile ).   MIDI events handle things related to the actual notes as well as sound texture, such as playing a note or moving the pitch-wheel.  META events take care of things like adding copyright text, authorship information, track naming etc.  SYSEX events are used to transmit arbitrary data. Their contents depend on the intended recipient.", 
            "title": "MIDI: The least you need to know"
        }, 
        {
            "location": "/midi/io/", 
            "text": "Basic MIDI Structures\n\n\n\n\nMIDIFile\n\n\n#\n\n\nMIDI.MIDIFile\n \n \nType\n.\n\n\nMIDIFile \n: Any\n\n\n\n\n\nType representing a file of MIDI data.\n\n\nFields\n\n\n\n\nformat::UInt16\n : The format of the file. Can be 0, 1 or 2.\n\n\ntpq::Int16\n : The time division of the track, ticks-per-quarter-note.\n\n\ntracks::Array{MIDITrack, 1}\n : The array of contained tracks.\n\n\n\n\nTo read and write a MIDI file, use\n\n\n#\n\n\nMIDI.readMIDIfile\n \n \nFunction\n.\n\n\nreadMIDIfile(filename::AbstractString)\n\n\n\n\n\nRead a file into a \nMIDIFile\n data type.\n\n\n#\n\n\nMIDI.writeMIDIfile\n \n \nFunction\n.\n\n\nwriteMIDIfile(filename::AbstractString, data::MIDIFile)\n\n\n\n\n\nWrite a \nMIDIFile\n as a \".mid\" file to the given filename.\n\n\nwriteMIDIfile(filename::AbstractString, notes::Notes)\n\n\n\n\n\nCreate a \nMIDIFile\n directly from \nnotes\n, using format 0.\n\n\n\n\n\n\nMIDITrack\n\n\nThe most important field of a \nMIDIFile\n is the \ntracks\n field. It contains as many tracks as the user wants. The tracks themselves contain all \"musical\" information in the form of the \"events\" we mentioned in the introduction:\n\n\n#\n\n\nMIDI.MIDITrack\n \n \nType\n.\n\n\nMIDITrack \n: Any\n\n\n\n\n\nMIDITrack\n is simply a container for \nTrackEvents\n, since its only field is \nevents::Vector{TrackEvent}\n.\n\n\nTrack chunks begin with four bytes spelling out \"MTrk\", followed by the length (in bytes) of the track (see \nreadvariablelength\n), followed by a sequence of events.\n\n\n#\n\n\nMIDI.TrackEvent\n \n \nType\n.\n\n\nTrackEvent \n: Any\n\n\n\n\n\nAbstract supertype for all MIDI events.\n\n\nAll track events begin with a variable length time value (see \nreadvariablelength\n) and have a field named \ndT\n which contains it. This number notes after how many ticks since the last event does the current even takes place.\n\n\nMIDIEvent\ns then resume with a MIDI channel message defined in \nconstants.jl\n. They're followed by 1 or 2 bytes, depending on the channel message (see \nMIDI.EVENTTYPETOLENGTH\n). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.\n\n\nMetaEvent\ns and \nSysexEvent\ns both resume with a specific byte (see \nconstants.jl\n).\n\n\n\n\nThe \nTrackEvent\n themselves can be one of three types:\n\n\nstruct\n \nMIDIEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \nstatus\n::\nUInt8\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\nstruct\n \nMetaEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \nmetatype\n::\nUInt8\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\nstruct\n \nSysexEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\n\n\n\nTypically the most relevant information of a \nMIDITrack\n are the notes contained within. For this reason, special functions \ngetnotes\n and \naddnotes!\n exist, which can be found in the \nNotes\n page.\n\n\n\n\nUtility functions\n\n\n#\n\n\nMIDI.BPM\n \n \nFunction\n.\n\n\nBPM(midi)\n\n\n\n\n\nReturn the BPM where the given \nMIDIFile\n was exported at.\n\n\n#\n\n\nMIDI.ms_per_tick\n \n \nFunction\n.\n\n\nms_per_tick(tpq, bpm)\nms_per_tick(midi::MIDIFile)\n\n\n\n\n\nReturn how many miliseconds is one tick, based on the beats per minute \nbpm\n and ticks per quarter note \ntpq\n.\n\n\n#\n\n\nMIDI.addevent!\n \n \nFunction\n.\n\n\naddevent!(track::MIDITrack, time::Int, event::TrackEvent)\n\n\n\n\n\nAdd an event to the \ntrack\n at given \ntime\n. The \ntime\n is in absolute time, not relative.\n\n\nIf you want to add multiple events in one go, you should use the \naddevents!\n function instead.\n\n\n#\n\n\nMIDI.addevents!\n \n \nFunction\n.\n\n\naddevents!(track::MIDITrack, times, events)\n\n\n\n\n\nAdd given \nevents\n to given \ntrack\n at given \ntimes\n, internally doing all translations from absolute time to relative time.\n\n\nUsing this function is more efficient than a loop over single \naddevent!\n calls.\n\n\n#\n\n\nMIDI.trackname\n \n \nFunction\n.\n\n\ntrackname(track::MIDI.MIDITrack)\n\n\n\n\n\nReturn the name of the given \ntrack\n as a string, by finding the \"track name\" \nMetaEvent\n.\n\n\n#\n\n\nMIDI.addtrackname!\n \n \nFunction\n.\n\n\naddtrackname!(track::MIDI.MIDITrack, name::String)\n\n\n\n\n\nAdd a name to the given \ntrack\n by attaching the \"track name\" \nMetaEvent\n to the start of the \ntrack\n.\n\n\n#\n\n\nMIDI.textevent\n \n \nFunction\n.\n\n\ntextevent(eventtype, text)\n\n\n\n\n\nCreate an event using the string \ntext\n. The \neventtype\n can be \n:text, :lyric, :marker\n, which will create the appropriate type of \nMetaEvent\n.\n\n\nThe returned event can be added to a \nMIDITrack\n via either \naddevent!\n or \naddevents!\n for multiple events.\n\n\nNotice\n - Cubase can read the marker events and MuseScore can read the lyrics events. We haven't seen any editor that can read the text events, so far.\n\n\n#\n\n\nMIDI.findtextevents\n \n \nFunction\n.\n\n\nfindtextevents(eventtype, track)\n\n\n\n\n\nFind all \"text\" events specifield by \neventtype\n in the \ntrack\n. The \neventtype\n can be \n:text, :lyric, :marker\n, which will find the appropriate \nMetaEvent\ns.\n\n\nFor convenience, this function does not return the events themselves. Instead, it returns three vectors: the first is the strings of the events, the second is the indices of the events in the \ntrack\n and the third is the absolute position of the events (since start of \ntrack\n).\n\n\nNotice\n - common music score editors like e.g. MuseScore, GuitarPro, etc., do not export the lyrics and text information when exporting midi files.\n\n\n\n\nLow-Level API\n\n\nIn this section we show the low-level API that allows one to actually read bytes from a file and transform them into Julia structures.\n\n\n#\n\n\nMIDI.readvariablelength\n \n \nFunction\n.\n\n\nreadvariablelength(f::IO)\n\n\n\n\n\nVariable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we're looking at the last byte in the sequence. The remaining 7 bits indicate the number.\n\n\nOther useful functions that are not exported are\n\n\nwriteevent\n\n\nreadMIDIevent\n\n\nreadmetaevent\n\n\nreadsysexevent\n\n\nget_abs_pos\n\n\n\n\n\n\n\n\nLastly, see the file \nMIDI/src/constants.jl\n for message types, event types, etc.", 
            "title": "MIDI files"
        }, 
        {
            "location": "/midi/io/#basic-midi-structures", 
            "text": "", 
            "title": "Basic MIDI Structures"
        }, 
        {
            "location": "/midi/io/#midifile", 
            "text": "#  MIDI.MIDIFile     Type .  MIDIFile  : Any  Type representing a file of MIDI data.  Fields   format::UInt16  : The format of the file. Can be 0, 1 or 2.  tpq::Int16  : The time division of the track, ticks-per-quarter-note.  tracks::Array{MIDITrack, 1}  : The array of contained tracks.   To read and write a MIDI file, use  #  MIDI.readMIDIfile     Function .  readMIDIfile(filename::AbstractString)  Read a file into a  MIDIFile  data type.  #  MIDI.writeMIDIfile     Function .  writeMIDIfile(filename::AbstractString, data::MIDIFile)  Write a  MIDIFile  as a \".mid\" file to the given filename.  writeMIDIfile(filename::AbstractString, notes::Notes)  Create a  MIDIFile  directly from  notes , using format 0.", 
            "title": "MIDIFile"
        }, 
        {
            "location": "/midi/io/#miditrack", 
            "text": "The most important field of a  MIDIFile  is the  tracks  field. It contains as many tracks as the user wants. The tracks themselves contain all \"musical\" information in the form of the \"events\" we mentioned in the introduction:  #  MIDI.MIDITrack     Type .  MIDITrack  : Any  MIDITrack  is simply a container for  TrackEvents , since its only field is  events::Vector{TrackEvent} .  Track chunks begin with four bytes spelling out \"MTrk\", followed by the length (in bytes) of the track (see  readvariablelength ), followed by a sequence of events.  #  MIDI.TrackEvent     Type .  TrackEvent  : Any  Abstract supertype for all MIDI events.  All track events begin with a variable length time value (see  readvariablelength ) and have a field named  dT  which contains it. This number notes after how many ticks since the last event does the current even takes place.  MIDIEvent s then resume with a MIDI channel message defined in  constants.jl . They're followed by 1 or 2 bytes, depending on the channel message (see  MIDI.EVENTTYPETOLENGTH ). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.  MetaEvent s and  SysexEvent s both resume with a specific byte (see  constants.jl ).   The  TrackEvent  themselves can be one of three types:  struct   MIDIEvent   :   TrackEvent \n     dT :: Int \n     status :: UInt8 \n     data :: Array { UInt8 , 1 }  end  struct   MetaEvent   :   TrackEvent \n     dT :: Int \n     metatype :: UInt8 \n     data :: Array { UInt8 , 1 }  end  struct   SysexEvent   :   TrackEvent \n     dT :: Int \n     data :: Array { UInt8 , 1 }  end   Typically the most relevant information of a  MIDITrack  are the notes contained within. For this reason, special functions  getnotes  and  addnotes!  exist, which can be found in the  Notes  page.", 
            "title": "MIDITrack"
        }, 
        {
            "location": "/midi/io/#utility-functions", 
            "text": "#  MIDI.BPM     Function .  BPM(midi)  Return the BPM where the given  MIDIFile  was exported at.  #  MIDI.ms_per_tick     Function .  ms_per_tick(tpq, bpm)\nms_per_tick(midi::MIDIFile)  Return how many miliseconds is one tick, based on the beats per minute  bpm  and ticks per quarter note  tpq .  #  MIDI.addevent!     Function .  addevent!(track::MIDITrack, time::Int, event::TrackEvent)  Add an event to the  track  at given  time . The  time  is in absolute time, not relative.  If you want to add multiple events in one go, you should use the  addevents!  function instead.  #  MIDI.addevents!     Function .  addevents!(track::MIDITrack, times, events)  Add given  events  to given  track  at given  times , internally doing all translations from absolute time to relative time.  Using this function is more efficient than a loop over single  addevent!  calls.  #  MIDI.trackname     Function .  trackname(track::MIDI.MIDITrack)  Return the name of the given  track  as a string, by finding the \"track name\"  MetaEvent .  #  MIDI.addtrackname!     Function .  addtrackname!(track::MIDI.MIDITrack, name::String)  Add a name to the given  track  by attaching the \"track name\"  MetaEvent  to the start of the  track .  #  MIDI.textevent     Function .  textevent(eventtype, text)  Create an event using the string  text . The  eventtype  can be  :text, :lyric, :marker , which will create the appropriate type of  MetaEvent .  The returned event can be added to a  MIDITrack  via either  addevent!  or  addevents!  for multiple events.  Notice  - Cubase can read the marker events and MuseScore can read the lyrics events. We haven't seen any editor that can read the text events, so far.  #  MIDI.findtextevents     Function .  findtextevents(eventtype, track)  Find all \"text\" events specifield by  eventtype  in the  track . The  eventtype  can be  :text, :lyric, :marker , which will find the appropriate  MetaEvent s.  For convenience, this function does not return the events themselves. Instead, it returns three vectors: the first is the strings of the events, the second is the indices of the events in the  track  and the third is the absolute position of the events (since start of  track ).  Notice  - common music score editors like e.g. MuseScore, GuitarPro, etc., do not export the lyrics and text information when exporting midi files.", 
            "title": "Utility functions"
        }, 
        {
            "location": "/midi/io/#low-level-api", 
            "text": "In this section we show the low-level API that allows one to actually read bytes from a file and transform them into Julia structures.  #  MIDI.readvariablelength     Function .  readvariablelength(f::IO)  Variable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we're looking at the last byte in the sequence. The remaining 7 bits indicate the number.  Other useful functions that are not exported are  writeevent  readMIDIevent  readmetaevent  readsysexevent  get_abs_pos    Lastly, see the file  MIDI/src/constants.jl  for message types, event types, etc.", 
            "title": "Low-Level API"
        }, 
        {
            "location": "/midi/notes/", 
            "text": "Notes\n\n\nNote information in MIDI files is typically encoded using \nNOTEON\n and \nNOTEOFF\n events. A music note however contains more information besides the start and end; we bundle this information with the following two types:\n\n\n#\n\n\nMIDI.Note\n \n \nType\n.\n\n\nNote \n: AbstractNote\n\n\n\n\n\nData structure describing a \"music note\".\n\n\nFields:\n\n\n\n\npitch::UInt8\n : Pitch, starting from C0 = 0, adding one per semitone (middle-C is 60).\n\n\nvelocity::UInt8\n : Dynamic intensity. Cannot be higher than 127 (0x7F).\n\n\nposition::UInt\n : Position in absolute time (since beginning of track), in ticks.\n\n\nduration::UInt\n : Duration in ticks.\n\n\nchannel::UInt8 = 0\n : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).\n\n\n\n\nIf the \nchannel\n of the note is \n0\n (default) it is not printed with \nshow\n.\n\n\n#\n\n\nMIDI.Notes\n \n \nType\n.\n\n\nNotes{N\n:AbstractNote}\n\n\n\n\n\nData structure describing a collection of \"music notes\", bundled with a ticks per quarter note measure.\n\n\nFields:\n\n\n\n\nnotes::Vector{N}\n\n\ntpq::Int16\n : Ticks per quarter note. Defines the fundamental unit of measurement  of a note's position and duration, as well as the length of one quarter note.  Takes values from 1 to 960.\n\n\n\n\nNotes\n is iterated and accessed as if iterating or accessing its field \nnotes\n.\n\n\n\n\nTo get all the notes in a \nMIDITrack\n, you can use\n\n\n#\n\n\nMIDI.getnotes\n \n \nFunction\n.\n\n\ngetnotes(midi::MIDIFile, trackno = 2)\n\n\n\n\n\nFind all NOTEON and NOTEOFF midi events in the \ntrackno\n track of a \nmidi\n, that correspond to the same note value (pitch) and convert them into the \nNote\n datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity. \ngetnotes\n takes care of this.\n\n\nNotice that the first track of a \nmidi\n doesn't have any notes.\n\n\ngetnotes(track::MIDITrack, tpq = 960)\n\n\n\n\n\nFind the notes from \ntrack\n directly, passing also the ticks per quarter note.\n\n\nReturns: \nNotes{Note}\n, setting the ticks per quarter note as \ntpq\n. You can find the originally exported ticks per quarter note from the original \nMIDIFile\n through \nmidi.tpq\n.\n\n\n\n\nIf you have some notes and you want to add them to a track, use\n\n\n#\n\n\nMIDI.addnotes!\n \n \nFunction\n.\n\n\naddnotes!(track::MIDITrack, notes)\n\n\n\n\n\nAdd given \nnotes\n to given \ntrack\n, internally doing all translations from absolute time to relative time.\n\n\n\n\nFinally, you can use the function \ngetnotnotes(track)\n to get all \nTrackEvents\n that are \nnot\n \nNOTEON\n or \nNOTEOFF\n.\n\n\n\n\nWrite Example\n\n\nusing\n \nMIDI\n\n\nC\n \n=\n \nNote\n(\n60\n,\n \n96\n,\n \n0\n,\n \n192\n)\n\n\nE\n \n=\n \nNote\n(\n64\n,\n \n96\n,\n \n48\n,\n \n144\n)\n\n\nG\n \n=\n \nNote\n(\n67\n,\n \n96\n,\n \n96\n,\n \n96\n)\n\n\n\ninc\n \n=\n \n192\n\n\nfile\n \n=\n \nMIDIFile\n()\n\n\ntrack\n \n=\n \nMIDITrack\n()\n\n\nnotes\n \n=\n \nNotes\n()\n \n# tpq automatically = 960\n\n\n\npush!\n(\nnotes\n,\n \nC\n)\n\n\npush!\n(\nnotes\n,\n \nE\n)\n\n\npush!\n(\nnotes\n,\n \nG\n)\n\n\n\n# Notes one octave higher\n\n\nC\n \n=\n \nNote\n(\n60\n \n+\n \n12\n,\n \n96\n,\n \nC\n.\nposition\n+\ninc\n,\n \n192\n)\n\n\nE\n \n=\n \nNote\n(\n64\n \n+\n \n12\n,\n \n96\n,\n \nE\n.\nposition\n+\ninc\n,\n \n144\n)\n\n\nG\n \n=\n \nNote\n(\n67\n \n+\n \n12\n,\n \n96\n,\n \nG\n.\nposition\n+\ninc\n,\n \n96\n)\n\n\n\naddnotes!\n(\ntrack\n,\n \nnotes\n)\n\n\naddtrackname!\n(\ntrack\n,\n \nsimple track\n)\n\n\npush!\n(\nfile\n.\ntracks\n,\n \ntrack\n)\n\n\nwriteMIDIfile\n(\ntest.mid\n,\n \nfile\n)\n\n\n\n\n\n\n\n\nRead Example\n\n\nusing\n \nMIDI\n\n\nmidi\n \n=\n \nreadMIDIfile\n(\ntestmidi\n())\n\n\n\n\n\n\nMIDIFile\n:\n\n  \nformat\n:\n \n1\n\n  \ntracks\n:\n \n4\n\n  \ntpq\n:\n \n960\n\n\n\n\n\n\n# Track number 3 is a quantized bass MIDI track\n\n\nbass\n \n=\n \nmidi\n.\ntracks\n[\n3\n]\n\n\nnotes\n \n=\n \ngetnotes\n(\nbass\n,\n \nmidi\n.\ntpq\n)\n\n\nprintln\n(\nNotes of track \n$\n(\ntrackname\n(\nbass\n))\n:\n)\n\n\nnotes\n\n\n\n\n\n\nNotes of track Bass:\n177 Notes with tpq=960\n Note A\u266f3 | vel = 95  | pos = 7680, dur = 690\n Note A\u266f3 | vel = 71  | pos = 9280, dur = 308\n Note G\u266f3 | vel = 52  | pos = 9600, dur = 668\n Note G\u266f3 | vel = 58  | pos = 11200, dur = 338\n Note G3  | vel = 71  | pos = 11520, dur = 701\n Note G\u266f3 | vel = 83  | pos = 13120, dur = 281\n Note G3  | vel = 73  | pos = 13440, dur = 855\n Note D3  | vel = 80  | pos = 14400, dur = 848\n Note C3  | vel = 68  | pos = 15360, dur = 986\n Note F\u266f2 | vel = 72  | pos = 16320, dur = 866\n  \u22ee\n\n\n\n\n\n\n\nPitch to \nInt\n convertion\n\n\n#\n\n\nMIDI.name_to_pitch\n \n \nFunction\n.\n\n\nname_to_pitch(p::String) -\n Int\n\n\n\n\n\nReturn the pitch value of the given note name \np\n, which can be of the form \ncapital_letter*sharp*octave\n. E.g. \nname_to_pitch(D#6)\n gives \n75\n.\n\n\n\n\ncapital_letter\n : from \n\"A\"\n to \n\"G\"\n.\n\n\nsharp\n : one of \n\"#\"\n \n\"\u266f\"\n or \n\"\"\n.\n\n\noctave\n : any integer (as a string), the octave number (an octave is 12 pitches). If not given it is assumed \n\"5\"\n.\n\n\n\n\nReminder: middle C has pitch \n60\n and is displayed as \nC5\n.\n\n\n#\n\n\nMIDI.pitch_to_name\n \n \nFunction\n.\n\n\npitch_to_name(pitch) -\n string\n\n\n\n\n\nReturn the name of the pitch, e.g. \nF5\n, \nA\u266f3\n etc. in modern notation given the value in integer.\n\n\nReminder: middle C has pitch \n60\n and is displayed as \nC5\n.\n\n\n\n\nConvenience Tools\n\n\nThe functions \nvelocities, positions, pitches, durations\n return the respective property when given some \nNotes\n.\n\n\nOther convenience functions follow:\n\n\n#\n\n\nMusicManipulations.translate\n \n \nFunction\n.\n\n\ntranslate(notes, ticks)\n\n\n\n\n\nTranslate the \nnotes\n for the given amount of \nticks\n.\n\n\n#\n\n\nBase.transpose\n \n \nFunction\n.\n\n\ntranspose(notes, semitones)\n\n\n\n\n\nTranspose the \nnotes\n for the given amount of \nsemitones\n.\n\n\n#\n\n\nMusicManipulations.randomnotes\n \n \nFunction\n.\n\n\nrandomnotes(n::Int, tpq = 960)\n\n\n\n\n\nGenerate some random notes that start sequentially.\n\n\n#\n\n\nMusicManipulations.subdivision\n \n \nFunction\n.\n\n\nsubdivision(n::Int, tpq)\n\n\n\n\n\nReturn how many ticks is the duration of the subdivision of a 4/4-bar into \nn\n equal parts, assuming the ticks per quarter note are \ntpq\n.\n\n\nFor example, for sixteenth notes you would do \nsubdivision(16, tpq)\n, for eigth-note triplets \nsubdivision(12, tpq)\n and so on.", 
            "title": "Notes"
        }, 
        {
            "location": "/midi/notes/#notes", 
            "text": "Note information in MIDI files is typically encoded using  NOTEON  and  NOTEOFF  events. A music note however contains more information besides the start and end; we bundle this information with the following two types:  #  MIDI.Note     Type .  Note  : AbstractNote  Data structure describing a \"music note\".  Fields:   pitch::UInt8  : Pitch, starting from C0 = 0, adding one per semitone (middle-C is 60).  velocity::UInt8  : Dynamic intensity. Cannot be higher than 127 (0x7F).  position::UInt  : Position in absolute time (since beginning of track), in ticks.  duration::UInt  : Duration in ticks.  channel::UInt8 = 0  : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).   If the  channel  of the note is  0  (default) it is not printed with  show .  #  MIDI.Notes     Type .  Notes{N :AbstractNote}  Data structure describing a collection of \"music notes\", bundled with a ticks per quarter note measure.  Fields:   notes::Vector{N}  tpq::Int16  : Ticks per quarter note. Defines the fundamental unit of measurement  of a note's position and duration, as well as the length of one quarter note.  Takes values from 1 to 960.   Notes  is iterated and accessed as if iterating or accessing its field  notes .   To get all the notes in a  MIDITrack , you can use  #  MIDI.getnotes     Function .  getnotes(midi::MIDIFile, trackno = 2)  Find all NOTEON and NOTEOFF midi events in the  trackno  track of a  midi , that correspond to the same note value (pitch) and convert them into the  Note  datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity.  getnotes  takes care of this.  Notice that the first track of a  midi  doesn't have any notes.  getnotes(track::MIDITrack, tpq = 960)  Find the notes from  track  directly, passing also the ticks per quarter note.  Returns:  Notes{Note} , setting the ticks per quarter note as  tpq . You can find the originally exported ticks per quarter note from the original  MIDIFile  through  midi.tpq .   If you have some notes and you want to add them to a track, use  #  MIDI.addnotes!     Function .  addnotes!(track::MIDITrack, notes)  Add given  notes  to given  track , internally doing all translations from absolute time to relative time.   Finally, you can use the function  getnotnotes(track)  to get all  TrackEvents  that are  not   NOTEON  or  NOTEOFF .", 
            "title": "Notes"
        }, 
        {
            "location": "/midi/notes/#write-example", 
            "text": "using   MIDI  C   =   Note ( 60 ,   96 ,   0 ,   192 )  E   =   Note ( 64 ,   96 ,   48 ,   144 )  G   =   Note ( 67 ,   96 ,   96 ,   96 )  inc   =   192  file   =   MIDIFile ()  track   =   MIDITrack ()  notes   =   Notes ()   # tpq automatically = 960  push! ( notes ,   C )  push! ( notes ,   E )  push! ( notes ,   G )  # Notes one octave higher  C   =   Note ( 60   +   12 ,   96 ,   C . position + inc ,   192 )  E   =   Note ( 64   +   12 ,   96 ,   E . position + inc ,   144 )  G   =   Note ( 67   +   12 ,   96 ,   G . position + inc ,   96 )  addnotes! ( track ,   notes )  addtrackname! ( track ,   simple track )  push! ( file . tracks ,   track )  writeMIDIfile ( test.mid ,   file )", 
            "title": "Write Example"
        }, 
        {
            "location": "/midi/notes/#read-example", 
            "text": "using   MIDI  midi   =   readMIDIfile ( testmidi ())   MIDIFile : \n   format :   1 \n   tracks :   4 \n   tpq :   960   # Track number 3 is a quantized bass MIDI track  bass   =   midi . tracks [ 3 ]  notes   =   getnotes ( bass ,   midi . tpq )  println ( Notes of track  $ ( trackname ( bass )) : )  notes   Notes of track Bass:\n177 Notes with tpq=960\n Note A\u266f3 | vel = 95  | pos = 7680, dur = 690\n Note A\u266f3 | vel = 71  | pos = 9280, dur = 308\n Note G\u266f3 | vel = 52  | pos = 9600, dur = 668\n Note G\u266f3 | vel = 58  | pos = 11200, dur = 338\n Note G3  | vel = 71  | pos = 11520, dur = 701\n Note G\u266f3 | vel = 83  | pos = 13120, dur = 281\n Note G3  | vel = 73  | pos = 13440, dur = 855\n Note D3  | vel = 80  | pos = 14400, dur = 848\n Note C3  | vel = 68  | pos = 15360, dur = 986\n Note F\u266f2 | vel = 72  | pos = 16320, dur = 866\n  \u22ee", 
            "title": "Read Example"
        }, 
        {
            "location": "/midi/notes/#pitch-to-int-convertion", 
            "text": "#  MIDI.name_to_pitch     Function .  name_to_pitch(p::String) -  Int  Return the pitch value of the given note name  p , which can be of the form  capital_letter*sharp*octave . E.g.  name_to_pitch(D#6)  gives  75 .   capital_letter  : from  \"A\"  to  \"G\" .  sharp  : one of  \"#\"   \"\u266f\"  or  \"\" .  octave  : any integer (as a string), the octave number (an octave is 12 pitches). If not given it is assumed  \"5\" .   Reminder: middle C has pitch  60  and is displayed as  C5 .  #  MIDI.pitch_to_name     Function .  pitch_to_name(pitch) -  string  Return the name of the pitch, e.g.  F5 ,  A\u266f3  etc. in modern notation given the value in integer.  Reminder: middle C has pitch  60  and is displayed as  C5 .", 
            "title": "Pitch to Int convertion"
        }, 
        {
            "location": "/midi/notes/#convenience-tools", 
            "text": "The functions  velocities, positions, pitches, durations  return the respective property when given some  Notes .  Other convenience functions follow:  #  MusicManipulations.translate     Function .  translate(notes, ticks)  Translate the  notes  for the given amount of  ticks .  #  Base.transpose     Function .  transpose(notes, semitones)  Transpose the  notes  for the given amount of  semitones .  #  MusicManipulations.randomnotes     Function .  randomnotes(n::Int, tpq = 960)  Generate some random notes that start sequentially.  #  MusicManipulations.subdivision     Function .  subdivision(n::Int, tpq)  Return how many ticks is the duration of the subdivision of a 4/4-bar into  n  equal parts, assuming the ticks per quarter note are  tpq .  For example, for sixteenth notes you would do  subdivision(16, tpq) , for eigth-note triplets  subdivision(12, tpq)  and so on.", 
            "title": "Convenience Tools"
        }, 
        {
            "location": "/mm/quantizing/", 
            "text": "Quantizing\n\n\n\n\nQuantization\n\n\nQuantization\n is the process of moving all note starting positions to a specified and periodic grid. This \"grid\" does not have the be equi-spaced but it has to be periodic per quarter note.\n\n\n#\n\n\nMusicManipulations.quantize\n \n \nFunction\n.\n\n\nquantize\n(\nnotes\n::\nNotes\n,\n \ngrid\n)\n\n\nquantize\n(\nnote\n::\nAbstractNote\n,\n \ngrid\n,\n \ntpq\n::\nInteger\n)\n\n\n\n\n\n\nReturn a quantized copy of the given notes on the given \ngrid\n, which can be any sorted iterable that starts on \n0\n and ends on \n1\n.\n\n\nEach note is quantized (relocated) to its closest point of the \ngrid\n, by first identifying that point using \nclassify\n. It is assumed that the grid is the same for all quarter notes of the track.\n\n\nThis function respects the notes' absolute position and quantizes in absolute position, not relative.\n\n\n\n\nHere are some examples\n\n\nusing\n \nMusicManipulations\n\n\nmidi\n \n=\n \nreadMIDIfile\n(\ntestmidi\n())\n\n\nnotes\n \n=\n \ngetnotes\n(\nmidi\n,\n \n4\n)\n\n\n\nsixteens\n \n=\n \n0\n:\n1\n//\n4\n:\n1\n\n\n\nnotes16\n \n=\n \nquantize\n(\nnotes\n,\n \nsixteens\n)\n\n\n\nswung_8s\n \n=\n \n[\n0\n,\n \n2\n//\n3\n,\n \n1\n]\n\n\n\nswung_notes\n \n=\n \nquantize\n(\nnotes\n,\n \nswung_8s\n)\n\n\n\n\n\n\n533 Notes with tpq=960\n Note F5  | vel = 69  | pos = 7360, dur = 181\n Note A\u266f5 | vel = 85  | pos = 7680, dur = 450\n Note D6  | vel = 91  | pos = 8320, dur = 356\n Note D5  | vel = 88  | pos = 8320, dur = 314\n Note G\u266f4 | vel = 88  | pos = 8320, dur = 358\n Note A\u266f5 | vel = 76  | pos = 8640, dur = 575\n Note G5  | vel = 66  | pos = 9280, dur = 273\n Note A\u266f5 | vel = 94  | pos = 9600, dur = 666\n Note F\u266f4 | vel = 98  | pos = 10240, dur = 307\n Note C5  | vel = 87  | pos = 10240, dur = 285\n  \u22ee\n\n\n\n\n\nThe first quantization quantized the notes on the 16-th subdivision. The second one did something a bit more specialized, as it separated the notes to \"quarter notes\" and swung 8th notes, the typical way a Jazz standard (like Serenade To A Cuckoo) is played.\n\n\n\n\nClassification\n\n\nquantize\n works in two steps. In the first step, each note is \"classified\", according to which is the closest grid point to this note (modulo the quarter note).\n\n\n#\n\n\nMusicManipulations.classify\n \n \nFunction\n.\n\n\nclassify\n(\nnotes\n::\nNotes\n,\n \ngrid\n)\n\n\nclassify\n(\nnote\n::\nAbstractNote\n,\n \ngrid\n,\n \ntpq\n::\nInteger\n)\n\n\n\n\n\n\nClassify given notes according to the given grid.\n\n\nReturns an integer (or vector of integers) that corresponds to the index of the closest grid point to the note position modulo the quarter note. \n1\n means start of the grid and \nlength(grid)\n means end of the grid (i.e. \nnext\n quarter note).\n\n\nAfter the notes have been classified, this classification vector is used to simply relocate all notes to the closest grid point (modulo the quarter note).", 
            "title": "Quantizing"
        }, 
        {
            "location": "/mm/quantizing/#quantizing", 
            "text": "", 
            "title": "Quantizing"
        }, 
        {
            "location": "/mm/quantizing/#quantization", 
            "text": "Quantization  is the process of moving all note starting positions to a specified and periodic grid. This \"grid\" does not have the be equi-spaced but it has to be periodic per quarter note.  #  MusicManipulations.quantize     Function .  quantize ( notes :: Notes ,   grid )  quantize ( note :: AbstractNote ,   grid ,   tpq :: Integer )   Return a quantized copy of the given notes on the given  grid , which can be any sorted iterable that starts on  0  and ends on  1 .  Each note is quantized (relocated) to its closest point of the  grid , by first identifying that point using  classify . It is assumed that the grid is the same for all quarter notes of the track.  This function respects the notes' absolute position and quantizes in absolute position, not relative.   Here are some examples  using   MusicManipulations  midi   =   readMIDIfile ( testmidi ())  notes   =   getnotes ( midi ,   4 )  sixteens   =   0 : 1 // 4 : 1  notes16   =   quantize ( notes ,   sixteens )  swung_8s   =   [ 0 ,   2 // 3 ,   1 ]  swung_notes   =   quantize ( notes ,   swung_8s )   533 Notes with tpq=960\n Note F5  | vel = 69  | pos = 7360, dur = 181\n Note A\u266f5 | vel = 85  | pos = 7680, dur = 450\n Note D6  | vel = 91  | pos = 8320, dur = 356\n Note D5  | vel = 88  | pos = 8320, dur = 314\n Note G\u266f4 | vel = 88  | pos = 8320, dur = 358\n Note A\u266f5 | vel = 76  | pos = 8640, dur = 575\n Note G5  | vel = 66  | pos = 9280, dur = 273\n Note A\u266f5 | vel = 94  | pos = 9600, dur = 666\n Note F\u266f4 | vel = 98  | pos = 10240, dur = 307\n Note C5  | vel = 87  | pos = 10240, dur = 285\n  \u22ee  The first quantization quantized the notes on the 16-th subdivision. The second one did something a bit more specialized, as it separated the notes to \"quarter notes\" and swung 8th notes, the typical way a Jazz standard (like Serenade To A Cuckoo) is played.", 
            "title": "Quantization"
        }, 
        {
            "location": "/mm/quantizing/#classification", 
            "text": "quantize  works in two steps. In the first step, each note is \"classified\", according to which is the closest grid point to this note (modulo the quarter note).  #  MusicManipulations.classify     Function .  classify ( notes :: Notes ,   grid )  classify ( note :: AbstractNote ,   grid ,   tpq :: Integer )   Classify given notes according to the given grid.  Returns an integer (or vector of integers) that corresponds to the index of the closest grid point to the note position modulo the quarter note.  1  means start of the grid and  length(grid)  means end of the grid (i.e.  next  quarter note).  After the notes have been classified, this classification vector is used to simply relocate all notes to the closest grid point (modulo the quarter note).", 
            "title": "Classification"
        }, 
        {
            "location": "/mm/extraction/", 
            "text": "Music Data Extraction\n\n\nThe functions described in this page allow for easier extraction of data from music recordings (in the form of MIDI).\n\n\n#\n\n\nMusicManipulations.firstnotes\n \n \nFunction\n.\n\n\nfirstnotes(notes, grid)\n\n\n\n\n\nReturn the notes that first appear in each grid point, \nwithout quantizing them\n.\n\n\nThis function \ndoes not\n consider the notes modulo the quarter note! Different quarter notes have different grid points.\n\n\n#\n\n\nMusicManipulations.allowedpitches\n \n \nFunction\n.\n\n\nallowedpitches(notes::Notes, allowed) -\n newnotes\n\n\n\n\n\nOnly keep the notes that have a pitch specified in \nallowed\n (one or many pitches).\n\n\n#\n\n\nMusicManipulations.separatepitches\n \n \nFunction\n.\n\n\nseparatepitches(notes::Notes [, allowed])\n\n\n\n\n\nGet a dictionary \"pitch\"=\n\"notes of that pitch\". Optionally only keep pitches that are contained in \nallowed\n.\n\n\n#\n\n\nMusicManipulations.timeseries\n \n \nFunction\n.\n\n\ntimeseries(notes::Notes, property, f [, grid]) -\n tvec, ts\n\n\n\n\n\nProduce a timeseries of the \nproperty\n of the given notes, optionally first quantizing on the given \ngrid\n.\n\n\nAfter quantization, it is often the case that many notes are in the same bin of the grid. The \nfunction\n \nf\n denotes which value of the vector of the \nproperty\n of the notes to keep. Typical values are \nminimum, maximum, mean\n, etc (\nfor type stability the returned timeseries are always \nFloat64\n).\n\n\nThe \nproperty\n can be \n:velocity\n, \n:pitch\n, or \n:duration\n. Grid bins without any notes are given the value \n0\n. This \ncan be problematic\n if you request for \n:pitch\n and your \nnotes\n also include notes which actually have pitch \n0\n, i.e. \nC0\n.", 
            "title": "Music Data Extraction"
        }, 
        {
            "location": "/mm/extraction/#music-data-extraction", 
            "text": "The functions described in this page allow for easier extraction of data from music recordings (in the form of MIDI).  #  MusicManipulations.firstnotes     Function .  firstnotes(notes, grid)  Return the notes that first appear in each grid point,  without quantizing them .  This function  does not  consider the notes modulo the quarter note! Different quarter notes have different grid points.  #  MusicManipulations.allowedpitches     Function .  allowedpitches(notes::Notes, allowed) -  newnotes  Only keep the notes that have a pitch specified in  allowed  (one or many pitches).  #  MusicManipulations.separatepitches     Function .  separatepitches(notes::Notes [, allowed])  Get a dictionary \"pitch\"= \"notes of that pitch\". Optionally only keep pitches that are contained in  allowed .  #  MusicManipulations.timeseries     Function .  timeseries(notes::Notes, property, f [, grid]) -  tvec, ts  Produce a timeseries of the  property  of the given notes, optionally first quantizing on the given  grid .  After quantization, it is often the case that many notes are in the same bin of the grid. The  function   f  denotes which value of the vector of the  property  of the notes to keep. Typical values are  minimum, maximum, mean , etc ( for type stability the returned timeseries are always  Float64 ).  The  property  can be  :velocity ,  :pitch , or  :duration . Grid bins without any notes are given the value  0 . This  can be problematic  if you request for  :pitch  and your  notes  also include notes which actually have pitch  0 , i.e.  C0 .", 
            "title": "Music Data Extraction"
        }, 
        {
            "location": "/motif/basic/", 
            "text": "Motif Sequence Generation\n\n\n#\n\n\nMotifSequenceGenerator.MotifSequenceGenerator\n \n \nModule\n.\n\n\nMotifSequenceGenerator\n\n\n\n\n\nThis module generates random sequences of motifs, under the constrain that the sequence has some total length \u2113 so that \nq - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q\n. All main functionality is given by the function \nrandom_sequence\n.\n\n\n#\n\n\nMotifSequenceGenerator.random_sequence\n \n \nFunction\n.\n\n\nrandom_sequence\n(\nmotifs\n::\nVector\n{\nM\n}\n,\n \nq\n,\n \nlimits\n,\n \ntranslate\n,\n \n\u03b4\nq\n \n=\n \n0\n;\n \nkwargs\n...)\n\n\n\n\n\n\nCreate a random sequence of motifs of type \nM\n, under the constraint that the sequence has \"length\" \n\u2113\n \nexactly\n within \nq - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q\n. Return the sequence itself as well as the sequence of indices of \nmotifs\n used to create it.\n\n\n\"length\" here means an abstracted length defined by the struct \nM\n, based on the \nlimits\n and \ntranslate\n functions. It does \nnot\n refer to the amount of elements!\n\n\nM\n can be anything, given the two functions\n\n\n\n\nlimits(motif)\n : Some function that given the \nmotif\n it returns the \n(start, fine)\n of the the motif in the same units as \nq\n. This function establishes a measure of length, which simply is \nfine - start\n.\n\n\ntranslate(motif, t)\n : Some function that given the \nmotif\n it returns a \nnew\n motif which is translated by \nt\n (either negative or positive), with respect to the same units as \nq\n.\n\n\n\n\nKeywords\n\n\nPlease see the source code (use \n@which\n) for a full description of the algorithm.\n\n\n\n\ntries = 5\n : Up to how many initial random sequences are accepted.\n\n\ntaulcut = 2\n : Up to how times an element is dropped from the initial guess.\n\n\nsummands = 3\n : Up to how many motifs may be combined as a sum to complete a sequence.\n\n\n\n\n\n\nSimple Example\n\n\nThis example illustrates how the module \nMotifSequenceGenerator\n works using a simple \nstruct\n. For a more realistic, and much more complex example, see the \nexample using music notes\n.\n\n\n\n\nLet's say that we want to create a random sequence of \"shouts\", which are described by the \nstruct\n\n\nstruct\n \nShout\n\n  \nshout\n::\nString\n\n  \nstart\n::\nInt\n\n\nend\n\n\n\n\n\n\nLet's first create a vector of shouts that will be used as the pool of possible motifs that will create the random sequence:\n\n\nusing\n \nRandom\n\n\nshouts\n \n=\n \n[\nShout\n(\nuppercase\n(\nrandstring\n(\nrand\n(\n3\n:\n5\n))),\n \nrand\n(\n1\n:\n100\n))\n \nfor\n \nk\n \nin\n \n1\n:\n5\n]\n\n\n\n\n\n\n5-element Array{Main.ex-shout.Shout,1}:\n Main.ex-shout.Shout(\nZHI\n, 47)\n Main.ex-shout.Shout(\n1Z8TG\n, 100)\n Main.ex-shout.Shout(\nNWNE\n, 13)\n Main.ex-shout.Shout(\nI0TF8\n, 92)\n Main.ex-shout.Shout(\nWU0DS\n, 18)\n\n\n\n\n\nNotice that at the moment the values of the \n.start\n field of \nShout\n are irrelevant. \nMotifSequenceGenerator\n will translate all motifs to start point 0 while operating.\n\n\nNow, to create a random sequence, we need to define two concepts:\n\n\nshoutlimits\n(\ns\n::\nShout\n)\n \n=\n \n(\ns\n.\nstart\n,\n \ns\n.\nstart\n \n+\n \nlength\n(\ns\n.\nshout\n)\n \n+\n \n1\n);\n\n\n\nshouttranslate\n(\ns\n::\nShout\n,\n \nn\n)\n \n=\n \nShout\n(\ns\n.\nshout\n,\n \ns\n.\nstart\n \n+\n \nn\n);\n\n\n\n\n\n\nThis means that we accept that the temporal length of a \nShout\n is \nlength(s.shout) + 1\n.\n\n\nWe can now create random sequences of shouts that have total length of \nexactly\n \nq\n:\n\n\nusing\n \nMotifSequenceGenerator\n\n\nq\n \n=\n \n30\n\n\nsequence\n,\n \nidxs\n \n=\n \nrandom_sequence\n(\nshouts\n,\n \nq\n,\n \nshoutlimits\n,\n \nshouttranslate\n)\n\n\nsequence\n\n\n\n\n\n\n6-element Array{Main.ex-shout.Shout,1}:\n Main.ex-shout.Shout(\n1Z8TG\n, 0)\n Main.ex-shout.Shout(\nZHI\n, 6)\n Main.ex-shout.Shout(\nI0TF8\n, 10)\n Main.ex-shout.Shout(\nNWNE\n, 16)\n Main.ex-shout.Shout(\nNWNE\n, 21)\n Main.ex-shout.Shout(\nZHI\n, 26)\n\n\n\n\n\nsequence\n,\n \nidxs\n \n=\n \nrandom_sequence\n(\nshouts\n,\n \nq\n,\n \nshoutlimits\n,\n \nshouttranslate\n)\n\n\nsequence\n\n\n\n\n\n\n6-element Array{Main.ex-shout.Shout,1}:\n Main.ex-shout.Shout(\n1Z8TG\n, 0)\n Main.ex-shout.Shout(\nNWNE\n, 6)\n Main.ex-shout.Shout(\nI0TF8\n, 11)\n Main.ex-shout.Shout(\nZHI\n, 17)\n Main.ex-shout.Shout(\nNWNE\n, 21)\n Main.ex-shout.Shout(\nZHI\n, 26)\n\n\n\n\n\nNotice that it is impossible to create a sequence of length e.g. \n7\n with the above pool. Doing \nrandom_sequence(shouts, 7, shoutlimits, shouttranslate)\n would throw an error.\n\n\n\n\nFloating point lengths\n\n\nThe lengths of the motifs do not have to be integers. When using motifs with floating lengths, it is advised to give a non-0 \n\u03b4q\n to \nrandom_sequence\n. The following example modifies the \nShout\n struct and shows how it can be done with floating length.\n\n\nstruct\n \nFloatShout\n\n  \nshout\n::\nString\n\n  \ndur\n::\nFloat64\n\n  \nstart\n::\nFloat64\n\n\nend\n\n\n\nrs\n(\nx\n)\n \n=\n \nuppercase\n(\nrandstring\n(\nx\n))\n\n\n\nshouts\n \n=\n \n[\nFloatShout\n(\nrs\n(\nrand\n(\n3\n:\n5\n)),\n \nrand\n()\n+\n1\n,\n \nrand\n())\n \nfor\n \nk\n \nin\n \n1\n:\n5\n]\n\n\nshoutlimits\n(\ns\n::\nFloatShout\n)\n \n=\n \n(\ns\n.\nstart\n,\n \ns\n.\nstart\n \n+\n \ns\n.\ndur\n);\n\n\nshouttranslate\n(\ns\n::\nFloatShout\n,\n \nn\n)\n \n=\n \nFloatShout\n(\ns\n.\nshout\n,\n \ns\n.\ndur\n,\n \ns\n.\nstart\n \n+\n \nn\n);\n\n\n\nq\n \n=\n \n10.0\n\n\n\u03b4q\n \n=\n \n1.0\n\n\n\nr\n,\n \ns\n \n=\n \nrandom_sequence\n(\nshouts\n,\n \nq\n,\n \nshoutlimits\n,\n \nshouttranslate\n,\n \n\u03b4q\n)\n\n\n\nr\n\n\n\n\n\n\n7-element Array{Main.ex-shout.FloatShout,1}:\n Main.ex-shout.FloatShout(\nYXP5\n, 1.7804455950447522, 0.0)\n Main.ex-shout.FloatShout(\n5JX\n, 1.1163104485981161, 1.7804455950447524)\n Main.ex-shout.FloatShout(\n93KA\n, 1.351716155934738, 2.8967560436428688)\n Main.ex-shout.FloatShout(\n93KA\n, 1.351716155934738, 4.2484721995776065)\n Main.ex-shout.FloatShout(\nP40O\n, 1.988119868220789, 5.600188355512344)\n Main.ex-shout.FloatShout(\n5JX\n, 1.1163104485981161, 7.588308223733133)\n Main.ex-shout.FloatShout(\nYXP5\n, 1.7804455950447522, 8.704618672331248)\n\n\n\n\n\ns\n\n\n\n\n\n\n7-element Array{Int64,1}:\n 3\n 2\n 5\n 5\n 4\n 2\n 3", 
            "title": "Motif Sequence Generation"
        }, 
        {
            "location": "/motif/basic/#motif-sequence-generation", 
            "text": "#  MotifSequenceGenerator.MotifSequenceGenerator     Module .  MotifSequenceGenerator  This module generates random sequences of motifs, under the constrain that the sequence has some total length \u2113 so that  q - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q . All main functionality is given by the function  random_sequence .  #  MotifSequenceGenerator.random_sequence     Function .  random_sequence ( motifs :: Vector { M } ,   q ,   limits ,   translate ,   \u03b4 q   =   0 ;   kwargs ...)   Create a random sequence of motifs of type  M , under the constraint that the sequence has \"length\"  \u2113   exactly  within  q - \u03b4q \u2264 \u2113 \u2264 q + \u03b4q . Return the sequence itself as well as the sequence of indices of  motifs  used to create it.  \"length\" here means an abstracted length defined by the struct  M , based on the  limits  and  translate  functions. It does  not  refer to the amount of elements!  M  can be anything, given the two functions   limits(motif)  : Some function that given the  motif  it returns the  (start, fine)  of the the motif in the same units as  q . This function establishes a measure of length, which simply is  fine - start .  translate(motif, t)  : Some function that given the  motif  it returns a  new  motif which is translated by  t  (either negative or positive), with respect to the same units as  q .   Keywords  Please see the source code (use  @which ) for a full description of the algorithm.   tries = 5  : Up to how many initial random sequences are accepted.  taulcut = 2  : Up to how times an element is dropped from the initial guess.  summands = 3  : Up to how many motifs may be combined as a sum to complete a sequence.", 
            "title": "Motif Sequence Generation"
        }, 
        {
            "location": "/motif/basic/#simple-example", 
            "text": "This example illustrates how the module  MotifSequenceGenerator  works using a simple  struct . For a more realistic, and much more complex example, see the  example using music notes .   Let's say that we want to create a random sequence of \"shouts\", which are described by the  struct  struct   Shout \n   shout :: String \n   start :: Int  end   Let's first create a vector of shouts that will be used as the pool of possible motifs that will create the random sequence:  using   Random  shouts   =   [ Shout ( uppercase ( randstring ( rand ( 3 : 5 ))),   rand ( 1 : 100 ))   for   k   in   1 : 5 ]   5-element Array{Main.ex-shout.Shout,1}:\n Main.ex-shout.Shout( ZHI , 47)\n Main.ex-shout.Shout( 1Z8TG , 100)\n Main.ex-shout.Shout( NWNE , 13)\n Main.ex-shout.Shout( I0TF8 , 92)\n Main.ex-shout.Shout( WU0DS , 18)  Notice that at the moment the values of the  .start  field of  Shout  are irrelevant.  MotifSequenceGenerator  will translate all motifs to start point 0 while operating.  Now, to create a random sequence, we need to define two concepts:  shoutlimits ( s :: Shout )   =   ( s . start ,   s . start   +   length ( s . shout )   +   1 );  shouttranslate ( s :: Shout ,   n )   =   Shout ( s . shout ,   s . start   +   n );   This means that we accept that the temporal length of a  Shout  is  length(s.shout) + 1 .  We can now create random sequences of shouts that have total length of  exactly   q :  using   MotifSequenceGenerator  q   =   30  sequence ,   idxs   =   random_sequence ( shouts ,   q ,   shoutlimits ,   shouttranslate )  sequence   6-element Array{Main.ex-shout.Shout,1}:\n Main.ex-shout.Shout( 1Z8TG , 0)\n Main.ex-shout.Shout( ZHI , 6)\n Main.ex-shout.Shout( I0TF8 , 10)\n Main.ex-shout.Shout( NWNE , 16)\n Main.ex-shout.Shout( NWNE , 21)\n Main.ex-shout.Shout( ZHI , 26)  sequence ,   idxs   =   random_sequence ( shouts ,   q ,   shoutlimits ,   shouttranslate )  sequence   6-element Array{Main.ex-shout.Shout,1}:\n Main.ex-shout.Shout( 1Z8TG , 0)\n Main.ex-shout.Shout( NWNE , 6)\n Main.ex-shout.Shout( I0TF8 , 11)\n Main.ex-shout.Shout( ZHI , 17)\n Main.ex-shout.Shout( NWNE , 21)\n Main.ex-shout.Shout( ZHI , 26)  Notice that it is impossible to create a sequence of length e.g.  7  with the above pool. Doing  random_sequence(shouts, 7, shoutlimits, shouttranslate)  would throw an error.", 
            "title": "Simple Example"
        }, 
        {
            "location": "/motif/basic/#floating-point-lengths", 
            "text": "The lengths of the motifs do not have to be integers. When using motifs with floating lengths, it is advised to give a non-0  \u03b4q  to  random_sequence . The following example modifies the  Shout  struct and shows how it can be done with floating length.  struct   FloatShout \n   shout :: String \n   dur :: Float64 \n   start :: Float64  end  rs ( x )   =   uppercase ( randstring ( x ))  shouts   =   [ FloatShout ( rs ( rand ( 3 : 5 )),   rand () + 1 ,   rand ())   for   k   in   1 : 5 ]  shoutlimits ( s :: FloatShout )   =   ( s . start ,   s . start   +   s . dur );  shouttranslate ( s :: FloatShout ,   n )   =   FloatShout ( s . shout ,   s . dur ,   s . start   +   n );  q   =   10.0  \u03b4q   =   1.0  r ,   s   =   random_sequence ( shouts ,   q ,   shoutlimits ,   shouttranslate ,   \u03b4q )  r   7-element Array{Main.ex-shout.FloatShout,1}:\n Main.ex-shout.FloatShout( YXP5 , 1.7804455950447522, 0.0)\n Main.ex-shout.FloatShout( 5JX , 1.1163104485981161, 1.7804455950447524)\n Main.ex-shout.FloatShout( 93KA , 1.351716155934738, 2.8967560436428688)\n Main.ex-shout.FloatShout( 93KA , 1.351716155934738, 4.2484721995776065)\n Main.ex-shout.FloatShout( P40O , 1.988119868220789, 5.600188355512344)\n Main.ex-shout.FloatShout( 5JX , 1.1163104485981161, 7.588308223733133)\n Main.ex-shout.FloatShout( YXP5 , 1.7804455950447522, 8.704618672331248)  s   7-element Array{Int64,1}:\n 3\n 2\n 5\n 5\n 4\n 2\n 3", 
            "title": "Floating point lengths"
        }, 
        {
            "location": "/motif/musicexample/", 
            "text": "Music Motif Examples\n\n\nIn this page \nMotifSequenceGenerator\n is applied in a real world case using the function \nrandom_notes_sequence\n:\n\n\n#\n\n\nMusicManipulations.random_notes_sequence\n \n \nFunction\n.\n\n\nrandom_notes_sequence(motifs::Vector{Notes{N}}, q, \u03b4q = 0)\n\n\n\n\n\nCreate a random sequence from a pool of notes (\nmotifs\n) such that it has total length exactly \nq \u00b1 \u03b4q\n. Notice that \nq\n is measured in \nticks\n.\n\n\nReturn the result as a single \nNotes\n container, and also return the sequence of motifs used.\n\n\nThis function uses \nrandom_sequence\n from the module \nMotifSequenceGenerator\n, adapted to the \nNotes\n struct.\n\n\n\n\nMotifs: Basic drum patterns\n\n\nLet's say that we have some basic drum patterns that we want to be able to combine freely at random combinations. For example,\n\n\n\n\nwhere the note E means right hand, while A means left hand. These patterns can be easily combined to fill a bar, like for example \n5b -\n 5b -\n 3 -\n 3\n or \n5a -\n 4 -\n 4 -\n 3\n, etc. They can also be combined to fill two bars and so on. Notice that some sequences, like e.g. the \n5a -\n 4 -\n 4 -\n 3\n, result in \nalternating hands\n: each time the sequence is played the hand that \"leads\" is swapped. This will be important later on.\n\n\nThe goal is to be able to play arbitrary sequences of them for arbitrary lengths. How does one practice that? We will use [\nrandom_notes_sequence\n] to create longer 8-bar sequences faster with the help of Julia.\n\n\n\n\nDefining the \nNotes\n\n\nWe first have to define the \nNotes\n instances that will correspond to those four basic patterns.\n\n\nusing\n \nMusicManipulations\n \n# re-exports MIDI\n\n\n\ntpq\n \n=\n \n960\n \n#\n\n\nsixt\n \n=\n \n240\n \n# duration of sixteenth note\n\n\nleft\n \n=\n \nname_to_pitch\n(\nA5\n)\n\n\nright\n \n=\n \nname_to_pitch\n(\nE6\n)\n\n\n\n\n\n\n76\n\n\n\n\n\nReminder: \nNote(pitch, intensity, start, duration)\n\n\nmotif1\n \n=\n \n[\n \n# motif 5a\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n100\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n3\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n4\nsixt\n,\n \nsixt\n)\n\n\n]\n\n\n\n\nmotif2\n \n=\n \n[\n \n# motif 5b\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n3\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n4\nsixt\n,\n \nsixt\n)\n\n\n]\n\n\n\nmotif3\n \n=\n \n[\n \n# motif 3\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\n]\n\n\n\nmotif4\n \n=\n \n[\n \n# motif 4\n\n\nNote\n(\nright\n,\n \n100\n,\n \n0\n,\n \nsixt\n),\n\n\nNote\n(\nleft\n,\n \n50\n,\n \nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n2\nsixt\n,\n \nsixt\n),\n\n\nNote\n(\nright\n,\n \n50\n,\n \n3\nsixt\n,\n \nsixt\n),\n\n\n]\n\n\n\nmotifs\n \n=\n \nNotes\n.\n([\nmotif1\n,\n \nmotif2\n,\n \nmotif3\n,\n \nmotif4\n],\n \ntpq\n)\n\n\n\n#%% #srs\n\n\n\n\n\n\nNow \nmotifs\n stands for a pool of note sequences we can draw random samples from. Let's generate sequences that are 8-bars long (i.e. 32 quarter notes)\n\n\nq\n \n=\n \ntpq\n*\n32\n\n\n\nnotes\n,\n \nseq\n \n=\n \nrandom_notes_sequence\n(\nmotifs\n,\n \nq\n)\n\n\nnotes\n\n\n\n\n\n\n128 Notes with tpq=960\n Note E6  | vel = 100 | pos = 0, dur = 240\n Note A5  | vel = 50  | pos = 240, dur = 240\n Note E6  | vel = 50  | pos = 480, dur = 240\n Note E6  | vel = 50  | pos = 720, dur = 240\n Note E6  | vel = 100 | pos = 960, dur = 240\n Note A5  | vel = 50  | pos = 1200, dur = 240\n Note A5  | vel = 50  | pos = 1440, dur = 240\n Note E6  | vel = 100 | pos = 1680, dur = 240\n Note A5  | vel = 50  | pos = 1920, dur = 240\n Note E6  | vel = 50  | pos = 2160, dur = 240\n  \u22ee\n\n\n\n\n\nand now we can write these to a MIDI file simply by doing \nwriteMIDIfile(\"drums_patterns.mid\", notes)\n.\n\n\nAfterwards we can drag-n-drop the midi file into a music score editor, like e.g. \nMuseScore\n, to visualize and print the result:\n\n\n\n\nthis is a pre-made figure - your random sequence will probably differ\n\n\nThis worked nicely, but there is a problem: The sequence does not respect the fact that some specific patterns (\n5a\n and \n4\n) swap the leading hand. This is what we tackle in the next section.\n\n\n\n\nAdding alternating hands and Lyrics\n\n\nNotice that \nrandom_note_sequence\n also returns the indices of the motifs that were used to create the sequence:\n\n\nseq\n\n\n\n\n\n\n31-element Array{Int64,1}:\n 4\n 3\n 4\n 1\n 4\n 1\n 4\n 2\n 4\n 3\n \u22ee\n 2\n 3\n 3\n 3\n 4\n 2\n 4\n 3\n 3\n\n\n\n\n\nWe can use this information to put the correct \"stickings\". To alternate hands we simply need to replace the necessary E notes with A and vice versa. Let's define some \"meta-data\" like structures\n\n\naccent1\n \n=\n \n(\n5a\n,\n \nfalse\n)\n\n\naccent2\n \n=\n \n(\n5b\n,\n \ntrue\n)\n\n\naccent3\n \n=\n \n(\n3\n,\n \nfalse\n)\n\n\naccent4\n \n=\n \n(\n4\n,\n \ntrue\n)\n\n\naccents\n \n=\n \n[\naccent1\n,\n \naccent2\n,\n \naccent3\n,\n \naccent4\n]\n\n\n\n\n\n\n4-element Array{Tuple{String,Bool},1}:\n (\n5a\n, false)\n (\n5b\n, true)\n (\n3\n, false)\n (\n4\n, true)\n\n\n\n\n\nThe first entry of each tuple is simply the name of the pattern which we will also show in our music score as \"lyrics\". The second entry of the tuple simply denotes whether the pattern swaps the leading hand.\n\n\nThe function that will \"inverse\" a note sticking is:\n\n\ninverse!\n(\nn\n::\nNote\n)\n \n=\n \n(\nn\n.\npitch\n \n=\n \n(\nn\n.\npitch\n \n==\n \nleft\n \n?\n \nright\n \n:\n \nleft\n));\n\n\n\n\n\n\nThe function that will \"count\" how long is each pattern, so that we put the lyrics on the correct positions in the score, will be:\n\n\nnote_length\n(\ns\n::\nString\n)\n \n=\n \nparse\n(\nInt\n,\n \ns\n[\n1\n]);\n\n\n\n\n\n\n(remember: \nsixt\n is the duration of one sixteenth note). We now initialize an empty \nMIDITrack\n and add all events to it!\n\n\ntrack\n \n=\n \nMIDITrack\n()\n\n\n\u2113\n \n=\n \n0\n\n\nright_leads\n \n=\n \ntrue\n\n\n\nfor\n \ni\n \nin\n \n1\n:\nlength\n(\nseq\n)\n\n\n    \ns\n \n=\n \naccents\n[\nseq\n[\ni\n]][\n1\n]\n\n    \nle\n \n=\n \ntextevent\n(\n:\nlyric\n,\n \ns\n)\n\n    \naddevent!\n(\ntrack\n,\n \n\u2113\n*\nsixt\n,\n \nle\n)\n\n\n    \nif\n \n!\nright_leads\n \n# Invert notes\n\n        \nfor\n \nj\n \nin\n \n\u2113\n+\n1\n:\n\u2113\n+\nnote_length\n(\ns\n)\n\n            \ninverse!\n(\nnotes\n[\nj\n])\n\n        \nend\n\n    \nend\n\n\n    \nglobal\n \n\u2113\n \n+=\n \nnote_length\n(\ns\n)\n\n\n    \nchange\n \n=\n \naccents\n[\nseq\n[\ni\n]][\n2\n]\n\n    \nglobal\n \nright_leads\n \n=\n \nxor\n(\nright_leads\n,\n \nchange\n)\n\n\nend\n\n\n!\nright_leads\n \n \ninverse!\n(\nnotes\n[\nend\n])\n\n\n\naddnotes!\n(\ntrack\n,\n \nnotes\n)\n\n\n\n\n\n\nFinally, we write the track as a midi file using \nwriteMIDIfile(\"drums_patterns_with_names.mid\", MIDIFile(0, tpq, [track]))\n and then we drag-n-drop the midi file into \nMuseScore\n.\n\n\n\n\nThis page was generated using \nLiterate.jl\n.", 
            "title": "Music Motifs Example"
        }, 
        {
            "location": "/motif/musicexample/#music-motif-examples", 
            "text": "In this page  MotifSequenceGenerator  is applied in a real world case using the function  random_notes_sequence :  #  MusicManipulations.random_notes_sequence     Function .  random_notes_sequence(motifs::Vector{Notes{N}}, q, \u03b4q = 0)  Create a random sequence from a pool of notes ( motifs ) such that it has total length exactly  q \u00b1 \u03b4q . Notice that  q  is measured in  ticks .  Return the result as a single  Notes  container, and also return the sequence of motifs used.  This function uses  random_sequence  from the module  MotifSequenceGenerator , adapted to the  Notes  struct.", 
            "title": "Music Motif Examples"
        }, 
        {
            "location": "/motif/musicexample/#motifs-basic-drum-patterns", 
            "text": "Let's say that we have some basic drum patterns that we want to be able to combine freely at random combinations. For example,   where the note E means right hand, while A means left hand. These patterns can be easily combined to fill a bar, like for example  5b -  5b -  3 -  3  or  5a -  4 -  4 -  3 , etc. They can also be combined to fill two bars and so on. Notice that some sequences, like e.g. the  5a -  4 -  4 -  3 , result in  alternating hands : each time the sequence is played the hand that \"leads\" is swapped. This will be important later on.  The goal is to be able to play arbitrary sequences of them for arbitrary lengths. How does one practice that? We will use [ random_notes_sequence ] to create longer 8-bar sequences faster with the help of Julia.", 
            "title": "Motifs: Basic drum patterns"
        }, 
        {
            "location": "/motif/musicexample/#defining-the-notes", 
            "text": "We first have to define the  Notes  instances that will correspond to those four basic patterns.  using   MusicManipulations   # re-exports MIDI  tpq   =   960   #  sixt   =   240   # duration of sixteenth note  left   =   name_to_pitch ( A5 )  right   =   name_to_pitch ( E6 )   76  Reminder:  Note(pitch, intensity, start, duration)  motif1   =   [   # motif 5a  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( right ,   100 ,   2 sixt ,   sixt ),  Note ( left ,   50 ,   3 sixt ,   sixt ),  Note ( left ,   50 ,   4 sixt ,   sixt )  ]  motif2   =   [   # motif 5b  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( left ,   50 ,   2 sixt ,   sixt ),  Note ( right ,   50 ,   3 sixt ,   sixt ),  Note ( right ,   50 ,   4 sixt ,   sixt )  ]  motif3   =   [   # motif 3  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( left ,   50 ,   2 sixt ,   sixt ),  ]  motif4   =   [   # motif 4  Note ( right ,   100 ,   0 ,   sixt ),  Note ( left ,   50 ,   sixt ,   sixt ),  Note ( right ,   50 ,   2 sixt ,   sixt ),  Note ( right ,   50 ,   3 sixt ,   sixt ),  ]  motifs   =   Notes . ([ motif1 ,   motif2 ,   motif3 ,   motif4 ],   tpq )  #%% #srs   Now  motifs  stands for a pool of note sequences we can draw random samples from. Let's generate sequences that are 8-bars long (i.e. 32 quarter notes)  q   =   tpq * 32  notes ,   seq   =   random_notes_sequence ( motifs ,   q )  notes   128 Notes with tpq=960\n Note E6  | vel = 100 | pos = 0, dur = 240\n Note A5  | vel = 50  | pos = 240, dur = 240\n Note E6  | vel = 50  | pos = 480, dur = 240\n Note E6  | vel = 50  | pos = 720, dur = 240\n Note E6  | vel = 100 | pos = 960, dur = 240\n Note A5  | vel = 50  | pos = 1200, dur = 240\n Note A5  | vel = 50  | pos = 1440, dur = 240\n Note E6  | vel = 100 | pos = 1680, dur = 240\n Note A5  | vel = 50  | pos = 1920, dur = 240\n Note E6  | vel = 50  | pos = 2160, dur = 240\n  \u22ee  and now we can write these to a MIDI file simply by doing  writeMIDIfile(\"drums_patterns.mid\", notes) .  Afterwards we can drag-n-drop the midi file into a music score editor, like e.g.  MuseScore , to visualize and print the result:   this is a pre-made figure - your random sequence will probably differ  This worked nicely, but there is a problem: The sequence does not respect the fact that some specific patterns ( 5a  and  4 ) swap the leading hand. This is what we tackle in the next section.", 
            "title": "Defining the Notes"
        }, 
        {
            "location": "/motif/musicexample/#adding-alternating-hands-and-lyrics", 
            "text": "Notice that  random_note_sequence  also returns the indices of the motifs that were used to create the sequence:  seq   31-element Array{Int64,1}:\n 4\n 3\n 4\n 1\n 4\n 1\n 4\n 2\n 4\n 3\n \u22ee\n 2\n 3\n 3\n 3\n 4\n 2\n 4\n 3\n 3  We can use this information to put the correct \"stickings\". To alternate hands we simply need to replace the necessary E notes with A and vice versa. Let's define some \"meta-data\" like structures  accent1   =   ( 5a ,   false )  accent2   =   ( 5b ,   true )  accent3   =   ( 3 ,   false )  accent4   =   ( 4 ,   true )  accents   =   [ accent1 ,   accent2 ,   accent3 ,   accent4 ]   4-element Array{Tuple{String,Bool},1}:\n ( 5a , false)\n ( 5b , true)\n ( 3 , false)\n ( 4 , true)  The first entry of each tuple is simply the name of the pattern which we will also show in our music score as \"lyrics\". The second entry of the tuple simply denotes whether the pattern swaps the leading hand.  The function that will \"inverse\" a note sticking is:  inverse! ( n :: Note )   =   ( n . pitch   =   ( n . pitch   ==   left   ?   right   :   left ));   The function that will \"count\" how long is each pattern, so that we put the lyrics on the correct positions in the score, will be:  note_length ( s :: String )   =   parse ( Int ,   s [ 1 ]);   (remember:  sixt  is the duration of one sixteenth note). We now initialize an empty  MIDITrack  and add all events to it!  track   =   MIDITrack ()  \u2113   =   0  right_leads   =   true  for   i   in   1 : length ( seq ) \n\n     s   =   accents [ seq [ i ]][ 1 ] \n     le   =   textevent ( : lyric ,   s ) \n     addevent! ( track ,   \u2113 * sixt ,   le ) \n\n     if   ! right_leads   # Invert notes \n         for   j   in   \u2113 + 1 : \u2113 + note_length ( s ) \n             inverse! ( notes [ j ]) \n         end \n     end \n\n     global   \u2113   +=   note_length ( s ) \n\n     change   =   accents [ seq [ i ]][ 2 ] \n     global   right_leads   =   xor ( right_leads ,   change )  end  ! right_leads     inverse! ( notes [ end ])  addnotes! ( track ,   notes )   Finally, we write the track as a midi file using  writeMIDIfile(\"drums_patterns_with_names.mid\", MIDIFile(0, tpq, [track]))  and then we drag-n-drop the midi file into  MuseScore .   This page was generated using  Literate.jl .", 
            "title": "Adding alternating hands and Lyrics"
        }
    ]
}