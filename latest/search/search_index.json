{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nThis documentation describes how to use packages of the \nJuliaMusic\n. They are about reading, manipulating and saving data exclusively related with music. Most of the functionality comes in the form of the \nMIDI\n format which is described later on this page.\n\n\n\n\nOverview\n\n\nThe \nMIDI.jl\n is a module that defines fundamental types like tracks, reading/writing functionality, note functionality and other basic stuff. It was originally developed by \nJoel Hobson\n and is now maintained by all members of JuliaMusic. In short it contains:\n\n\n\n\nThe API of basic types like midi files and tracks, as well as IO is in the \nBasic MIDI Structures\n page.\n\n\nThe \nNote\n construct which describes a music note, as well as basic read/write methods, are in the \nNotes\n page.\n\n\n\n\nThe \nMusicManipulations.jl\n package has more advanced functionality about note processing, data extraction, quantizing and other similar processes that related to music data:\n\n\n\n\nQuantizing \n Classifying Notes\n on a given grid.\n\n\nMusic Data Extraction\n\n\nMore coming soon.\n\n\n\n\n\n\nMIDI: The least you need to know\n\n\nThis section serves as a crash-course on the MIDI format. For more info see the \nwikipedia\n page, read the \nofficial MIDI specifications\n or have a look at the comprehensive tutorial \nat recirdingblogs.com\n.\n\n\nA MIDI file typically comes in pieces called tracks that play simultaneously. Each track can have 16 different channels, numbered 0-15. Each channel can be thought of as a single instrument, though that instrument can be changed throughout that track. A track contains events. The three types of events are MIDI events, META events, and system exclusive (SYSEX) events. All events begin with the time since the last event (dT) in ticks. The number of ticks per quarter note is given by the \ntpq\n of the midi file, \nMIDIFile.tpq\n (see \nMIDIFile\n).\n\n\n\n\nMIDI events handle things related to the actual notes as well as sound texture, such as playing a note or moving the pitch-wheel.\n\n\nMETA events take care of things like adding copyright text, authorship information, track naming etc.\n\n\nSYSEX events are used to transmit arbitrary data. Their contents depend on the intended recipient.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "This documentation describes how to use packages of the  JuliaMusic . They are about reading, manipulating and saving data exclusively related with music. Most of the functionality comes in the form of the  MIDI  format which is described later on this page.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#overview", 
            "text": "The  MIDI.jl  is a module that defines fundamental types like tracks, reading/writing functionality, note functionality and other basic stuff. It was originally developed by  Joel Hobson  and is now maintained by all members of JuliaMusic. In short it contains:   The API of basic types like midi files and tracks, as well as IO is in the  Basic MIDI Structures  page.  The  Note  construct which describes a music note, as well as basic read/write methods, are in the  Notes  page.   The  MusicManipulations.jl  package has more advanced functionality about note processing, data extraction, quantizing and other similar processes that related to music data:   Quantizing   Classifying Notes  on a given grid.  Music Data Extraction  More coming soon.", 
            "title": "Overview"
        }, 
        {
            "location": "/#midi-the-least-you-need-to-know", 
            "text": "This section serves as a crash-course on the MIDI format. For more info see the  wikipedia  page, read the  official MIDI specifications  or have a look at the comprehensive tutorial  at recirdingblogs.com .  A MIDI file typically comes in pieces called tracks that play simultaneously. Each track can have 16 different channels, numbered 0-15. Each channel can be thought of as a single instrument, though that instrument can be changed throughout that track. A track contains events. The three types of events are MIDI events, META events, and system exclusive (SYSEX) events. All events begin with the time since the last event (dT) in ticks. The number of ticks per quarter note is given by the  tpq  of the midi file,  MIDIFile.tpq  (see  MIDIFile ).   MIDI events handle things related to the actual notes as well as sound texture, such as playing a note or moving the pitch-wheel.  META events take care of things like adding copyright text, authorship information, track naming etc.  SYSEX events are used to transmit arbitrary data. Their contents depend on the intended recipient.", 
            "title": "MIDI: The least you need to know"
        }, 
        {
            "location": "/midi/io/", 
            "text": "Basic MIDI Structures\n\n\n\n\nMIDIFile\n\n\n#\n\n\nMIDI.MIDIFile\n \n \nType\n.\n\n\nMIDIFile \n: Any\n\n\n\n\n\nType representing a file of MIDI data.\n\n\nFields\n\n\n\n\nformat::UInt16\n : The format of the file. Can be 0, 1 or 2.\n\n\ntpq::Int16\n : The time division of the track, ticks-per-beat.\n\n\ntracks::Array{MIDITrack, 1}\n : The array of contained tracks.\n\n\n\n\nTo read and write a MIDI file, use\n\n\nmidi\n \n=\n \nreadMIDIfile\n(\ntest.mid\n)\n \n# Reads a file into a MIDIFile data type\n\n\nwriteMIDIfile\n(\nfilename.mid\n,\n \nmidi\n)\n \n# Writes a MIDI file to the given filename\n\n\n\n\n\n\n\n\n\n\nMIDITrack\n\n\nThe most important field of a \nMIDIFile\n is the \ntracks\n field. It contains as many tracks as the user wants. The tracks themselves contain all \"musical\" information in the form of the \"events\" we mentioned in the introduction:\n\n\n#\n\n\nMIDI.MIDITrack\n \n \nType\n.\n\n\nMIDITrack \n: Any\n\n\n\n\n\nMIDITrack\n is simply a container for \nTrackEvents\n, since its only field is \nevents::Vector{TrackEvent}\n.\n\n\nTrack chunks begin with four bytes spelling out \"MTrk\", followed by the length (in bytes) of the track (see \nreadvariablelength\n), followed by a sequence of events.\n\n\n#\n\n\nMIDI.TrackEvent\n \n \nType\n.\n\n\nTrackEvent \n: Any\n\n\n\n\n\nAbstract supertype for all MIDI events.\n\n\nAll track events begin with a variable length time value (see \nreadvariablelength\n) and have a field named \ndT\n which contains it. This number notes after how many ticks since the last event does the current even takes place.\n\n\nMIDIEvent\ns then resume with a MIDI channel message defined in \nconstants.jl\n. They're followed by 1 or 2 bytes, depending on the channel message (see \nMIDI.EVENTTYPETOLENGTH\n). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.\n\n\nMetaEvent\ns and \nSysexEvent\ns both resume with a specific byte (see \nconstants.jl\n).\n\n\nThe \nTrackEvent\n themselves can be one of three types:\n\n\nstruct\n \nMIDIEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \nstatus\n::\nUInt8\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\nstruct\n \nMetaEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \nmetatype\n::\nUInt8\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\nstruct\n \nSysexEvent\n \n:\n \nTrackEvent\n\n    \ndT\n::\nInt\n\n    \ndata\n::\nArray\n{\nUInt8\n,\n1\n}\n\n\nend\n\n\n\n\n\n\nTypically the most relevant information of a \nMIDITrack\n are the notes contained within. For this reason, special functions \ngetnotes\n and \naddnotes!\n exist, which can be found in the \nNotes\n page.\n\n\n\n\nUtility functions\n\n\n#\n\n\nMIDI.BPM\n \n \nFunction\n.\n\n\nBPM(midi)\n\n\n\n\n\nReturn the BPM where the given \nMIDIFile\n was exported at.\n\n\n#\n\n\nMIDI.ms_per_tick\n \n \nFunction\n.\n\n\nms_per_tick(midi, bpm::Integer = BPM(midi)) -\n ms\n\n\n\n\n\nGiven a \nMIDIFile\n, return how many miliseconds is one tick, based on the \nbpm\n. By default the \nbpm\n is the BPM the midi file was exported at.\n\n\n#\n\n\nMIDI.addevent!\n \n \nFunction\n.\n\n\naddevent!(track::MIDITrack, time::Int, event::TrackEvent)\n\n\n\n\n\nAdd an event to the \ntrack\n at given \ntime\n. The \ntime\n is in absolute time, not relative.\n\n\nIf you want to add multiple events in one go, you should use the \naddevents!\n function instead.\n\n\n#\n\n\nMIDI.addevents!\n \n \nFunction\n.\n\n\naddevents!(track::MIDITrack, times, events)\n\n\n\n\n\nAdd given \nevents\n to given \ntrack\n at given \ntimes\n, internally doing all translations from absolute time to relative time.\n\n\nUsing this function is more efficient than a loop over single \naddevent!\n calls.\n\n\n#\n\n\nMIDI.trackname\n \n \nFunction\n.\n\n\ntrackname(track::MIDI.MIDITrack)\n\n\n\n\n\nReturn the name of the given \nMIDITrack\n as a string, by finding the \"track name\" \nMetaEvent\n.\n\n\n#\n\n\nMIDI.addtrackname!\n \n \nFunction\n.\n\n\naddtrackname!(track::MIDI.MIDITrack, name::String)\n\n\n\n\n\nAdd a name of the given \nMIDITrack\n by attaching the correct \"track name\" \nMetaEvent\n to the track.\n\n\n\n\nLow-Level API\n\n\nIn this section we show the low-level API that allows one to actually read bytes from a file and transform them into Julia structures.\n\n\n#\n\n\nMIDI.readvariablelength\n \n \nFunction\n.\n\n\nreadvariablelength(f::IO)\n\n\n\n\n\nVariable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we're looking at the last byte in the sequence. The remaining 7 bits indicate the number.\n\n\nOther useful functions that are not exported are\n\n\nwriteevent\n\n\nreadMIDIevent\n\n\nreadmetaevent\n\n\nreadsysexevent\n\n\n\n\n\n\nLastly, see the file \nMIDI/src/constants.jl\n for message types, event types, etc.", 
            "title": "MIDI files"
        }, 
        {
            "location": "/midi/io/#basic-midi-structures", 
            "text": "", 
            "title": "Basic MIDI Structures"
        }, 
        {
            "location": "/midi/io/#midifile", 
            "text": "#  MIDI.MIDIFile     Type .  MIDIFile  : Any  Type representing a file of MIDI data.  Fields   format::UInt16  : The format of the file. Can be 0, 1 or 2.  tpq::Int16  : The time division of the track, ticks-per-beat.  tracks::Array{MIDITrack, 1}  : The array of contained tracks.   To read and write a MIDI file, use  midi   =   readMIDIfile ( test.mid )   # Reads a file into a MIDIFile data type  writeMIDIfile ( filename.mid ,   midi )   # Writes a MIDI file to the given filename", 
            "title": "MIDIFile"
        }, 
        {
            "location": "/midi/io/#miditrack", 
            "text": "The most important field of a  MIDIFile  is the  tracks  field. It contains as many tracks as the user wants. The tracks themselves contain all \"musical\" information in the form of the \"events\" we mentioned in the introduction:  #  MIDI.MIDITrack     Type .  MIDITrack  : Any  MIDITrack  is simply a container for  TrackEvents , since its only field is  events::Vector{TrackEvent} .  Track chunks begin with four bytes spelling out \"MTrk\", followed by the length (in bytes) of the track (see  readvariablelength ), followed by a sequence of events.  #  MIDI.TrackEvent     Type .  TrackEvent  : Any  Abstract supertype for all MIDI events.  All track events begin with a variable length time value (see  readvariablelength ) and have a field named  dT  which contains it. This number notes after how many ticks since the last event does the current even takes place.  MIDIEvent s then resume with a MIDI channel message defined in  constants.jl . They're followed by 1 or 2 bytes, depending on the channel message (see  MIDI.EVENTTYPETOLENGTH ). If no valid channel message is identified, the previous seen channel message is used. After that the MIDI command is encoded.  MetaEvent s and  SysexEvent s both resume with a specific byte (see  constants.jl ).  The  TrackEvent  themselves can be one of three types:  struct   MIDIEvent   :   TrackEvent \n     dT :: Int \n     status :: UInt8 \n     data :: Array { UInt8 , 1 }  end  struct   MetaEvent   :   TrackEvent \n     dT :: Int \n     metatype :: UInt8 \n     data :: Array { UInt8 , 1 }  end  struct   SysexEvent   :   TrackEvent \n     dT :: Int \n     data :: Array { UInt8 , 1 }  end   Typically the most relevant information of a  MIDITrack  are the notes contained within. For this reason, special functions  getnotes  and  addnotes!  exist, which can be found in the  Notes  page.", 
            "title": "MIDITrack"
        }, 
        {
            "location": "/midi/io/#utility-functions", 
            "text": "#  MIDI.BPM     Function .  BPM(midi)  Return the BPM where the given  MIDIFile  was exported at.  #  MIDI.ms_per_tick     Function .  ms_per_tick(midi, bpm::Integer = BPM(midi)) -  ms  Given a  MIDIFile , return how many miliseconds is one tick, based on the  bpm . By default the  bpm  is the BPM the midi file was exported at.  #  MIDI.addevent!     Function .  addevent!(track::MIDITrack, time::Int, event::TrackEvent)  Add an event to the  track  at given  time . The  time  is in absolute time, not relative.  If you want to add multiple events in one go, you should use the  addevents!  function instead.  #  MIDI.addevents!     Function .  addevents!(track::MIDITrack, times, events)  Add given  events  to given  track  at given  times , internally doing all translations from absolute time to relative time.  Using this function is more efficient than a loop over single  addevent!  calls.  #  MIDI.trackname     Function .  trackname(track::MIDI.MIDITrack)  Return the name of the given  MIDITrack  as a string, by finding the \"track name\"  MetaEvent .  #  MIDI.addtrackname!     Function .  addtrackname!(track::MIDI.MIDITrack, name::String)  Add a name of the given  MIDITrack  by attaching the correct \"track name\"  MetaEvent  to the track.", 
            "title": "Utility functions"
        }, 
        {
            "location": "/midi/io/#low-level-api", 
            "text": "In this section we show the low-level API that allows one to actually read bytes from a file and transform them into Julia structures.  #  MIDI.readvariablelength     Function .  readvariablelength(f::IO)  Variable length numbers in MIDI files are represented as a sequence of bytes. If the first bit is 0, we're looking at the last byte in the sequence. The remaining 7 bits indicate the number.  Other useful functions that are not exported are  writeevent  readMIDIevent  readmetaevent  readsysexevent   Lastly, see the file  MIDI/src/constants.jl  for message types, event types, etc.", 
            "title": "Low-Level API"
        }, 
        {
            "location": "/midi/notes/", 
            "text": "Notes\n\n\nNote information in MIDI files is typically encoded using \nNOTEON\n and \nNOTEOFF\n events. A music note however contains more information besides the start and end; we bundle this information with the following two types:\n\n\n#\n\n\nMIDI.Note\n \n \nType\n.\n\n\nNote \n: AbstractNote\n\n\n\n\n\nData structure describing a \"music note\".\n\n\nFields:\n\n\n\n\npitch::UInt8\n : Pitch, starting from C0 = 0, adding one per semitone (middle-C is 60).\n\n\nvelocity::UInt8\n : Dynamic intensity. Cannot be higher than 127 (0x7F).\n\n\nposition::UInt\n : Position in absolute time (since beginning of track), in ticks.\n\n\nduration::UInt\n : Duration in ticks.\n\n\nchannel::UInt8 = 0\n : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).\n\n\n\n\nIf the \nchannel\n of the note is \n0\n (default) it is not printed with \nshow\n.\n\n\n#\n\n\nMIDI.Notes\n \n \nType\n.\n\n\nNotes{N\n:AbstractNote}\n\n\n\n\n\nData structure describing a collection of \"music notes\", bundled with a ticks per quarter note measure.\n\n\nFields:\n\n\n\n\nnotes::Vector{N}\n\n\ntpq::Int16\n : Ticks per quarter note. Defines the fundamental unit of measurement  of a note's position and duration, as well as the length of one quarter note.  Takes pitchs from 1 to 960.\n\n\n\n\nNotes\n is iterated and accessed as if iterating or accessing its field \nnotes\n.\n\n\nTo get all the notes in a \nMIDITrack\n, you can use\n\n\n#\n\n\nMIDI.getnotes\n \n \nFunction\n.\n\n\ngetnotes(midi::MIDIFile, trackno = 2)\n\n\n\n\n\nFind all NOTEON and NOTEOFF midi events in the \ntrackno\n track of a \nmidi\n, that correspond to the same note value (pitch) and convert them into the \nNote\n datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity. \ngetnotes\n takes care of this.\n\n\nNotice that the first track of a \nmidi\n doesn't have any notes.\n\n\ngetnotes(track::MIDITrack, tpq = 960)\n\n\n\n\n\nFind the notes from \ntrack\n directly, passing also the ticks per quarter note.\n\n\nReturns: \nNotes{Note}\n, setting the ticks per quarter note as \ntpq\n. You can find the originally exported ticks per quarter note from the original \nMIDIFile\n through \nmidi.tpq\n.\n\n\nIf you have some notes and you want to add them to a track, use\n\n\n#\n\n\nMIDI.addnotes!\n \n \nFunction\n.\n\n\naddnotes!(track::MIDITrack, notes)\n\n\n\n\n\nAdd given \nnotes\n to given \ntrack\n, internally doing all translations from absolute time to relative time.\n\n\nFinally, you can use the function \ngetnotnotes(track)\n to get all \nTrackEvents\n that are \nnot\n \nNOTEON\n or \nNOTEOFF\n.\n\n\n\n\nWrite Example\n\n\nusing\n \nMIDI\n\n\nC\n \n=\n \nNote\n(\n60\n,\n \n96\n,\n \n0\n,\n \n192\n)\n\n\nE\n \n=\n \nNote\n(\n64\n,\n \n96\n,\n \n48\n,\n \n144\n)\n\n\nG\n \n=\n \nNote\n(\n67\n,\n \n96\n,\n \n96\n,\n \n96\n)\n\n\n\ninc\n \n=\n \n192\n\n\nfile\n \n=\n \nMIDIFile\n()\n\n\ntrack\n \n=\n \nMIDITrack\n()\n\n\nnotes\n \n=\n \nNotes\n()\n\n\n\npush!\n(\nnotes\n,\n \nC\n)\n\n\npush!\n(\nnotes\n,\n \nE\n)\n\n\npush!\n(\nnotes\n,\n \nG\n)\n\n\n\n# Notes one octave higher\n\n\nC\n \n=\n \nNote\n(\n60\n \n+\n \n12\n,\n \n96\n,\n \nC\n.\nposition\n+\ninc\n,\n \n192\n)\n\n\nE\n \n=\n \nNote\n(\n64\n \n+\n \n12\n,\n \n96\n,\n \nE\n.\nposition\n+\ninc\n,\n \n144\n)\n\n\nG\n \n=\n \nNote\n(\n67\n \n+\n \n12\n,\n \n96\n,\n \nG\n.\nposition\n+\ninc\n,\n \n96\n)\n\n\ni\n \n+=\n \n1\n\n\n\naddnotes!\n(\ntrack\n,\n \nnotes\n)\n\n\naddtrackname!\n(\ntrack\n,\n \nsimple track\n)\n\n\npush!\n(\nfile\n.\ntracks\n,\n \ntrack\n)\n\n\nwriteMIDIfile\n(\ntest.mid\n,\n \nfile\n)\n\n\n\n\n\n\n\n\nRead Example\n\n\ncd\n(\nPkg\n.\ndir\n(\nMusicManipulations\n)\n*\n/test\n)\n\n\nmidi\n \n=\n \nreadMIDIfile\n(\nserenade_full.mid\n)\n\n\n# Track number 3 is a quantized bass MIDI track\n\n\nbass\n \n=\n \nmidi\n.\ntracks\n[\n3\n]\n\n\nnotes\n \n=\n \ngetnotes\n(\nbass\n,\n \nmidi\n.\ntpq\n)\n\n\nprintln\n(\nNotes of track \n$\n(\ntrackname\n(\nbass\n))\n:\n)\n\n\nBase\n.\nshow\n(\nnotes\n)\n\n\n\n\n\n\ngives\n\n\nNotes of track Bass:\n256 Notes with tpq=960\n Note F3   | vel = 76  | pos = 0, dur = 1196\n Note F3   | vel = 75  | pos = 1600, dur = 273\n Note D\u266f3  | vel = 58  | pos = 1920, dur = 1496\n Note D\u266f3  | vel = 56  | pos = 3520, dur = 274\n Note C\u266f3  | vel = 60  | pos = 3840, dur = 1421\n Note C\u266f3  | vel = 58  | pos = 5440, dur = 228\n Note C3   | vel = 73  | pos = 5760, dur = 889\n Note D\u266f3  | vel = 77  | pos = 6720, dur = 967\n Note F3   | vel = 76  | pos = 7680, dur = 1196\n Note F3   | vel = 75  | pos = 9280, dur = 273\n  \u22ee\n\n\n\n\n\n\n\nPitch to \nInt\n convertion\n\n\nTo get the pitch number for a specific note, multiply 12 by the octave number, and add it to one of the following\n\n\n\n\nC  = 0\n\n\nC\u266f = 1\n\n\nD\u266d = 1\n\n\nD  = 2\n\n\nD\u266f = 3\n\n\nE\u266d = 3\n\n\nE  = 4\n\n\nF  = 5\n\n\nF\u266f = 6\n\n\nGb = 6\n\n\nG  = 7\n\n\nG\u266f = 8\n\n\nA\u266d = 8\n\n\nA  = 9\n\n\nA\u266f = 10\n\n\nB\u266d = 10\n\n\nB  = 11\n\n\nC\u266d = 11", 
            "title": "Notes"
        }, 
        {
            "location": "/midi/notes/#notes", 
            "text": "Note information in MIDI files is typically encoded using  NOTEON  and  NOTEOFF  events. A music note however contains more information besides the start and end; we bundle this information with the following two types:  #  MIDI.Note     Type .  Note  : AbstractNote  Data structure describing a \"music note\".  Fields:   pitch::UInt8  : Pitch, starting from C0 = 0, adding one per semitone (middle-C is 60).  velocity::UInt8  : Dynamic intensity. Cannot be higher than 127 (0x7F).  position::UInt  : Position in absolute time (since beginning of track), in ticks.  duration::UInt  : Duration in ticks.  channel::UInt8 = 0  : Channel of the track that the note is played on. Cannot be higher than 127 (0x7F).   If the  channel  of the note is  0  (default) it is not printed with  show .  #  MIDI.Notes     Type .  Notes{N :AbstractNote}  Data structure describing a collection of \"music notes\", bundled with a ticks per quarter note measure.  Fields:   notes::Vector{N}  tpq::Int16  : Ticks per quarter note. Defines the fundamental unit of measurement  of a note's position and duration, as well as the length of one quarter note.  Takes pitchs from 1 to 960.   Notes  is iterated and accessed as if iterating or accessing its field  notes .  To get all the notes in a  MIDITrack , you can use  #  MIDI.getnotes     Function .  getnotes(midi::MIDIFile, trackno = 2)  Find all NOTEON and NOTEOFF midi events in the  trackno  track of a  midi , that correspond to the same note value (pitch) and convert them into the  Note  datatype. There are special cases where NOTEOFF is actually encoded as NOTEON with 0 velocity.  getnotes  takes care of this.  Notice that the first track of a  midi  doesn't have any notes.  getnotes(track::MIDITrack, tpq = 960)  Find the notes from  track  directly, passing also the ticks per quarter note.  Returns:  Notes{Note} , setting the ticks per quarter note as  tpq . You can find the originally exported ticks per quarter note from the original  MIDIFile  through  midi.tpq .  If you have some notes and you want to add them to a track, use  #  MIDI.addnotes!     Function .  addnotes!(track::MIDITrack, notes)  Add given  notes  to given  track , internally doing all translations from absolute time to relative time.  Finally, you can use the function  getnotnotes(track)  to get all  TrackEvents  that are  not   NOTEON  or  NOTEOFF .", 
            "title": "Notes"
        }, 
        {
            "location": "/midi/notes/#write-example", 
            "text": "using   MIDI  C   =   Note ( 60 ,   96 ,   0 ,   192 )  E   =   Note ( 64 ,   96 ,   48 ,   144 )  G   =   Note ( 67 ,   96 ,   96 ,   96 )  inc   =   192  file   =   MIDIFile ()  track   =   MIDITrack ()  notes   =   Notes ()  push! ( notes ,   C )  push! ( notes ,   E )  push! ( notes ,   G )  # Notes one octave higher  C   =   Note ( 60   +   12 ,   96 ,   C . position + inc ,   192 )  E   =   Note ( 64   +   12 ,   96 ,   E . position + inc ,   144 )  G   =   Note ( 67   +   12 ,   96 ,   G . position + inc ,   96 )  i   +=   1  addnotes! ( track ,   notes )  addtrackname! ( track ,   simple track )  push! ( file . tracks ,   track )  writeMIDIfile ( test.mid ,   file )", 
            "title": "Write Example"
        }, 
        {
            "location": "/midi/notes/#read-example", 
            "text": "cd ( Pkg . dir ( MusicManipulations ) * /test )  midi   =   readMIDIfile ( serenade_full.mid )  # Track number 3 is a quantized bass MIDI track  bass   =   midi . tracks [ 3 ]  notes   =   getnotes ( bass ,   midi . tpq )  println ( Notes of track  $ ( trackname ( bass )) : )  Base . show ( notes )   gives  Notes of track Bass:\n256 Notes with tpq=960\n Note F3   | vel = 76  | pos = 0, dur = 1196\n Note F3   | vel = 75  | pos = 1600, dur = 273\n Note D\u266f3  | vel = 58  | pos = 1920, dur = 1496\n Note D\u266f3  | vel = 56  | pos = 3520, dur = 274\n Note C\u266f3  | vel = 60  | pos = 3840, dur = 1421\n Note C\u266f3  | vel = 58  | pos = 5440, dur = 228\n Note C3   | vel = 73  | pos = 5760, dur = 889\n Note D\u266f3  | vel = 77  | pos = 6720, dur = 967\n Note F3   | vel = 76  | pos = 7680, dur = 1196\n Note F3   | vel = 75  | pos = 9280, dur = 273\n  \u22ee", 
            "title": "Read Example"
        }, 
        {
            "location": "/midi/notes/#pitch-to-int-convertion", 
            "text": "To get the pitch number for a specific note, multiply 12 by the octave number, and add it to one of the following   C  = 0  C\u266f = 1  D\u266d = 1  D  = 2  D\u266f = 3  E\u266d = 3  E  = 4  F  = 5  F\u266f = 6  Gb = 6  G  = 7  G\u266f = 8  A\u266d = 8  A  = 9  A\u266f = 10  B\u266d = 10  B  = 11  C\u266d = 11", 
            "title": "Pitch to Int convertion"
        }, 
        {
            "location": "/mm/quantizing/", 
            "text": "Quantizing\n\n\nQuantization\n is the process of moving all note starting positions to a specified and periodic grid. This \"grid\" does not have the be equi-spaced but it has to be periodic per quarter note.\n\n\n#\n\n\nMusicManipulations.quantize\n \n \nFunction\n.\n\n\nquantize\n(\nnotes\n::\nNotes\n,\n \ngrid\n)\n\n\nquantize\n(\nnote\n::\nAbstractNote\n,\n \ngrid\n,\n \ntpq\n::\nInteger\n)\n\n\n\n\n\n\nReturn a quantized copy of the given notes on the given \ngrid\n, which can be any sorted iterable that starts on \n0\n and ends on \n1\n.\n\n\nEach note is quantized (relocated) to its closest point of the \ngrid\n, by first identifying that point using \nclassify\n. It is assumed that the grid is the same for all quarter notes of the track.\n\n\nThis function respects the notes' absolute position and quantizes in absolute position, not relative.\n\n\nsource\n\n\nHere are some examples\n\n\nusing\n \nMusicManipulations\n\n\ncd\n(\nPkg\n.\ndir\n(\nMusicManipulations\n)\n*\n/test\n)\n\n\nmidi\n \n=\n \nreadMIDIfile\n(\nserenade_full.mid\n)\n\n\nnotes\n \n=\n \ngetnotes\n(\nmidi\n,\n \n4\n)\n\n\n\nsixteens\n \n=\n \n0\n:\n1\n//\n4\n:\n1\n\n\n\nnotes16\n \n=\n \nquantize\n(\nnotes\n,\n \nsixteens\n)\n\n\n\nswung_8s\n \n=\n \n[\n0\n,\n \n2\n//\n3\n,\n \n1\n]\n\n\n\nswung_notes\n \n=\n \nquantize\n(\nnotes\n,\n \nswung_8s\n)\n\n\n\n\n\n\n640 Notes with tpq=960\n Note C6   | vel = 86  | pos = 16000, dur = 292\n Note G4   | vel = 61  | pos = 16000, dur = 291\n Note G\u266f4  | vel = 50  | pos = 16000, dur = 260\n Note C5   | vel = 34  | pos = 16000, dur = 218\n Note F5   | vel = 66  | pos = 16960, dur = 274\n Note G\u266f4  | vel = 40  | pos = 17280, dur = 1762\n Note G4   | vel = 47  | pos = 17280, dur = 1760\n Note C6   | vel = 87  | pos = 17280, dur = 1639\n Note C5   | vel = 36  | pos = 17280, dur = 1760\n Note F5   | vel = 54  | pos = 18880, dur = 220\n  \u22ee\n\n\n\n\n\nThe first quantization quantized the notes on the 16-th subdivision. The second one did something a bit more specialized, as it separated the notes to \"quarter notes\" and swung 8th notes, the typical way a Jazz standard (like Serenade To A Cuckoo) is played.\n\n\n\n\nClassification\n\n\nquantize\n works in two steps. In the first step, each note is \"classified\", according to which is the closest grid point to this note (modulo the quarter note).\n\n\n#\n\n\nMusicManipulations.classify\n \n \nFunction\n.\n\n\nclassify\n(\nnotes\n::\nNotes\n,\n \ngrid\n)\n\n\nclassify\n(\nnote\n::\nAbstractNote\n,\n \ngrid\n,\n \ntpq\n::\nInteger\n)\n\n\n\n\n\n\nClassify given notes according to the given grid.\n\n\nReturns an integer (or vector of integers) that corresponds to the index of the closest grid point to the note position modulo the quarter note. \n1\n means start of the grid and \nlength(grid)\n means end of the grid (i.e. \nnext\n quarter note).\n\n\nsource\n\n\nAfter the notes have been classified, this classification vector is used to simply relocate all notes to the closest grid point (modulo the quarter note).", 
            "title": "Quantizing"
        }, 
        {
            "location": "/mm/quantizing/#quantizing", 
            "text": "Quantization  is the process of moving all note starting positions to a specified and periodic grid. This \"grid\" does not have the be equi-spaced but it has to be periodic per quarter note.  #  MusicManipulations.quantize     Function .  quantize ( notes :: Notes ,   grid )  quantize ( note :: AbstractNote ,   grid ,   tpq :: Integer )   Return a quantized copy of the given notes on the given  grid , which can be any sorted iterable that starts on  0  and ends on  1 .  Each note is quantized (relocated) to its closest point of the  grid , by first identifying that point using  classify . It is assumed that the grid is the same for all quarter notes of the track.  This function respects the notes' absolute position and quantizes in absolute position, not relative.  source  Here are some examples  using   MusicManipulations  cd ( Pkg . dir ( MusicManipulations ) * /test )  midi   =   readMIDIfile ( serenade_full.mid )  notes   =   getnotes ( midi ,   4 )  sixteens   =   0 : 1 // 4 : 1  notes16   =   quantize ( notes ,   sixteens )  swung_8s   =   [ 0 ,   2 // 3 ,   1 ]  swung_notes   =   quantize ( notes ,   swung_8s )   640 Notes with tpq=960\n Note C6   | vel = 86  | pos = 16000, dur = 292\n Note G4   | vel = 61  | pos = 16000, dur = 291\n Note G\u266f4  | vel = 50  | pos = 16000, dur = 260\n Note C5   | vel = 34  | pos = 16000, dur = 218\n Note F5   | vel = 66  | pos = 16960, dur = 274\n Note G\u266f4  | vel = 40  | pos = 17280, dur = 1762\n Note G4   | vel = 47  | pos = 17280, dur = 1760\n Note C6   | vel = 87  | pos = 17280, dur = 1639\n Note C5   | vel = 36  | pos = 17280, dur = 1760\n Note F5   | vel = 54  | pos = 18880, dur = 220\n  \u22ee  The first quantization quantized the notes on the 16-th subdivision. The second one did something a bit more specialized, as it separated the notes to \"quarter notes\" and swung 8th notes, the typical way a Jazz standard (like Serenade To A Cuckoo) is played.", 
            "title": "Quantizing"
        }, 
        {
            "location": "/mm/quantizing/#classification", 
            "text": "quantize  works in two steps. In the first step, each note is \"classified\", according to which is the closest grid point to this note (modulo the quarter note).  #  MusicManipulations.classify     Function .  classify ( notes :: Notes ,   grid )  classify ( note :: AbstractNote ,   grid ,   tpq :: Integer )   Classify given notes according to the given grid.  Returns an integer (or vector of integers) that corresponds to the index of the closest grid point to the note position modulo the quarter note.  1  means start of the grid and  length(grid)  means end of the grid (i.e.  next  quarter note).  source  After the notes have been classified, this classification vector is used to simply relocate all notes to the closest grid point (modulo the quarter note).", 
            "title": "Classification"
        }, 
        {
            "location": "/mm/extraction/", 
            "text": "Music Data Extraction\n\n\nadvanced data extraction.", 
            "title": "Music Data Extraction"
        }, 
        {
            "location": "/mm/extraction/#music-data-extraction", 
            "text": "advanced data extraction.", 
            "title": "Music Data Extraction"
        }
    ]
}